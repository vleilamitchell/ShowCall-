o## Feature Plan: Events Review Remediations (Follow-up to 0002)

### Context
This plan implements the remediations identified in the Events feature review (0002_REVIEW.md):
- "relation app.events does not exist" risk due to schema/migration mismatch
- `require('crypto')` fallback for id generation may fail in ESM/edge
- Excessive `PATCH` frequency during inline title edits
- Missing route-driven selection (`/events/:eventId`)

The work spans data model alignment, API hardening, and UI/route improvements.

---

### Scope of changes (files/functions)
- Data layer
  - `server/src/schema/events.ts`: Align Drizzle table to the same schema used by migrations (public), removing the custom `app` schema so the ORM targets `public.events`.
  - `server/drizzle/0001_events.sql`: No structural change if we align the Drizzle model to public. Confirm indexes remain against `public.events`.

- API (Hono)
  - `server/src/api.ts`
    - Event creation handler under `/api/v1/events` (POST): Replace id generation fallback to be environment-safe (Node + edge). Ensure no `require()` use at runtime in ESM/edge.

- UI (React)
  - `ui/src/pages/Events.tsx`
    - Inline title edit: Introduce client-side debounce (single-flight updates, cancellations on rapid typing) to avoid chatty `PATCH`.
    - Initialize selected event from route params and update URL on selection changes.
  - `ui/src/App.tsx`
    - Add `/events/:eventId` optional param route alongside `/events` so selection can be deep-linked.

- API client
  - `ui/src/lib/serverComm.ts`
    - No shape change expected; confirm `updateEvent` remains idempotent with debounced calls.

---

### Detailed requirements

#### 1) Data model alignment (critical)
- Problem (from review): Drizzle model references `app.events` while migration creates `public.events` — will cause runtime errors ("relation app.events does not exist").
- Approach (Option A from review recommendations): Standardize on public schema.
  - In `server/src/schema/events.ts`, remove use of a custom `pgSchema('app')` and define the `events` table with the default/public schema so Drizzle queries `public.events`.
  - Verify other models (if any) also use public schema for consistency.
  - Rebuild the server to confirm Drizzle types and generated SQL align with `public.events`.
  - No migration file changes required if we target public. If any prior runtime used `app.events`, perform a one-time data copy, otherwise skip.

Acceptance:
- Drizzle `events` queries succeed without schema-qualification errors.
- Listing, creating, and updating events continue to function with unchanged response shapes.

#### 2) Harden id generation in API
- Problem: `require('crypto')` fallback may fail in ESM/edge (review notes ESM/Cloudflare Workers risk).
- Approach:
  - Prefer `globalThis.crypto.randomUUID()` when available.
  - For Node-only fallback, import from the Node standard library at module scope and only use it when `globalThis.crypto` is unavailable at runtime.
  - Eliminate usage of `require()` for id generation to keep compatibility with ESM/edge runtimes.

Acceptance:
- Event creation works in both Node and edge-like environments without runtime import errors.

#### 3) Debounce chatty title updates in UI
- Problem: Inline title edit currently fires a `PATCH` on every keystroke.
- Approach:
  - In `ui/src/pages/Events.tsx`, wrap the title `onChange` handler with a ~300–500ms debounce (choose 400ms). Cancel pending updates when input changes rapidly; flush on blur or Enter to avoid losing the last edit.
  - Ensure only the latest value is sent; ignore stale in-flight responses to avoid out-of-order updates.
  - Keep local state optimistic so the UI remains responsive.

Acceptance:
- While typing quickly, at most one request every ~400ms is sent; a final update is sent on blur/submit.
- No visual regressions; the list reflects the debounced update.

#### 4) Route-driven selection for Events
- Problem: Selection is local state only; URLs are not shareable.
- Approach:
  - `ui/src/App.tsx`: Add route `/events/:eventId` (eventId optional) in addition to `/events` to maintain backward compatibility.
  - `ui/src/pages/Events.tsx`:
    - On mount, read `eventId` param and set selected row accordingly; if not present, default to current behavior.
    - When a row is clicked/selected, push URL update to `/events/<id>` using React Router navigation.
    - On list refresh, if `eventId` is set but not present in the results, clear selection and route back to `/events`.

Acceptance:
- Navigating directly to `/events/<id>` selects and shows that event.
- Clicking rows updates the URL; back/forward restores selection.

---

### Phasing
- Phase 1: Data layer (schema alignment)
  - Update `server/src/schema/events.ts` to target public schema.
  - Verify server boots and can query `public.events`.

- Phase 2A: API hardening (id generation)
  - Update id generation in `server/src/api.ts` POST handler to avoid `require()` and support edge.

- Phase 2B: UI optimization (debounce title edit)
  - Add debounce around title updates in `ui/src/pages/Events.tsx` with final flush on blur.

- Phase 2C: Routing (route-driven selection)
  - Add `/events/:eventId` route in `ui/src/App.tsx` and wire selection logic in `ui/src/pages/Events.tsx`.

Phases 2A–2C can be implemented in parallel after Phase 1.

---

### Test plan (high-level)
- Data layer
  - Boot server; create an event; list events; update an event title.
  - Ensure no "relation app.events does not exist" errors occur in logs or responses.

- API
  - Simulate environments with and without `globalThis.crypto` (unit/integration) to validate id generation path coverage.

- UI
  - Type quickly in title; confirm debounced network calls (Network tab) and final flush on blur.
  - Navigate to `/events/<id>` directly; confirm selection and details load. Click rows and verify URL updates. Use back/forward navigation.

---

### Notes and constraints
- Keep response shapes stable; no API contract changes expected.
- No new dependencies required; debounce can be implemented locally.
- If future models introduce schemas, re-evaluate consistent schema strategy across the project to avoid fragmented namespaces.


