### Inventory Core and Ledger — Technical Plan

Brief context (verbatim from Brief_0001):
- "Unify around a single inventory “core,” then let departments extend it via schemas and policies—don’t fork data models per department."
- One canonical Item with `item_type` enum: `Consumable`, `ReturnableAsset`, `FixedAsset`, `Perishable`, `Rental`, `Kit` and a single immutable InventoryLedger of movements. Type- and department-specific fields live in JSONB validated against a versioned AttributeSchema.
- Single movement model: all stock-affecting events are normalized `InventoryTransaction` rows; current balances are projections. Costing attaches to ledger events. Reservations reduce availability without posting a stock movement.

This plan implements the inventory core, event ledger, policies, reservations, and projections, wired into the existing Hono API, Drizzle schema, and React UI.

---

### Data Layer (Phase 1)

Create new Postgres structures via SQL migrations and Drizzle schema modules.

- Enums
  - `item_type`: `Consumable`, `ReturnableAsset`, `FixedAsset`, `Perishable`, `Rental`, `Kit`
  - `event_type`: `RECEIPT`, `TRANSFER_OUT`, `TRANSFER_IN`, `CONSUMPTION`, `WASTE`, `COUNT_ADJUST`, `RESERVATION_HOLD`, `RESERVATION_RELEASE`, `MOVE_OUT`, `MOVE_IN`, `MAINTENANCE_START`, `MAINTENANCE_END`

- Core tables
  - `attribute_schema` — versioned JSON schema per `(item_type[, department_id])`
    - Columns: `schema_id uuid pk`, `item_type item_type not null`, `department_id uuid null`, `version int not null`, `json_schema jsonb not null`
    - Unique: `(item_type, department_id, version)`
  - `item` — single canonical item
    - Columns: `item_id uuid pk`, `sku text unique not null`, `name text not null`, `item_type item_type not null`, `base_unit text not null`, `category_id uuid null`, `schema_id uuid not null -> attribute_schema`, `attributes jsonb not null`, `active boolean not null default true`
    - Indexes: `sku`, `(item_type)`, `(category_id)`
  - `asset_specs` — optional subtype for assets
    - Columns: `item_id uuid pk -> item`, `requires_serial boolean default true`, `service_interval_days int null`
  - `location`
    - Columns: `location_id uuid pk`, `name text not null`, `department_id uuid not null`
    - Indexes: `(department_id, name)` unique per department
  - `inventory_txn` — immutable ledger of events
    - Columns: `txn_id uuid pk`, `ts timestamptz not null default now()`, `item_id uuid not null -> item`, `location_id uuid not null -> location`, `event_type event_type not null`, `qty_base numeric not null`, `lot_id uuid null`, `serial_no text null`, `cost_per_base numeric null`, `source_doc jsonb null`, `posted_by uuid not null`
    - Indexes: `(item_id, location_id, ts desc)`, `(event_type, ts desc)`, `(lot_id)`
    - Write policy: append-only (no UPDATE/DELETE). Corrections are reversing entries.
  - `reservation`
    - Columns: `res_id uuid pk`, `item_id uuid not null -> item`, `location_id uuid not null -> location`, `event_id uuid not null`, `qty_base numeric not null`, `start_ts timestamptz not null`, `end_ts timestamptz not null`, `status text check in ('HELD','RELEASED','FULFILLED')`
    - Indexes: `(item_id, start_ts, end_ts)`, `(event_id)`
  - `policy`
    - Columns: `policy_id uuid pk`, `department_id uuid not null`, `item_type item_type not null`, `key text not null`, `value jsonb not null`
    - Index: `(department_id, item_type, key)` unique

- Units & packaging
  - `unit_conversion` (minimal to start): `from_unit text`, `to_unit text`, `factor numeric`, unique `(from_unit, to_unit)`.
  - Store all ledger `qty_base` in the item’s `base_unit`. Convert UI inputs using conversion factors.

- Projections (derived, not hand-edited)
  - `on_hand` materialized view or cached table: aggregated `sum(qty_base)` by `(item_id, location_id, lot_id)`.
  - `availability` view: `on_hand.qty_base − active_reservations.qty_base_in_window`.
  - `valuation` tables: start with rolling average per `(item_id[, lot_id])`; optionally add FIFO layers later.

- Files to create/update (server)
  - Migrations: `server/drizzle/0009_inventory_core.sql`, `server/drizzle/0010_inventory_projections.sql`
  - Schema modules: `server/src/schema/inventory/enums.ts`, `.../items.ts`, `.../assetSpecs.ts`, `.../locations.ts`, `.../inventoryTxn.ts`, `.../reservations.ts`, `.../policies.ts`, `.../units.ts`
  - Export from aggregator: `server/src/schema/index.ts` (ensure new tables/enums are exported)
  - Validators: extend `server/src/lib/validators.ts` with `isValidUnit`, `isValidEventType`, numeric/JSON helpers

Execution
- Use `server/scripts/apply-sql-migrations.mjs` to apply new `.sql` files. Ensure `DATABASE_URL` is set or local dev DB is running (dynamic port supported by `scripts/port-manager.js`).

---

### Service Layer & Algorithms (Phase 2A)

Implement service routines (no direct SQL in routes) that use Drizzle and enforce policies. Place helpers near route handlers or in `server/src/services/inventory/*.ts` (new directory).

- Attribute validation
  - Fetch `attribute_schema.json_schema` by `schema_id` on the `item` row.
  - Validate `item.attributes` against the JSON schema (server-side). Consider `ajv` for JSON Schema validation.
    - If adding, install in server: `pnpm add ajv ajv-formats`.

- Unit conversion
  - On input, if payload specifies `unit` ≠ item `base_unit`, convert using `unit_conversion.factor` to compute `qty_base`.

- Policy enforcement (keyed by `(department_id, item_type[, category_id])`)
  - On posting a transaction: check allowed `event_type`s, reservation requirement, UoM restrictions, par logic, and costing method.

- Posting algorithm (ledger)
  1) Load `item`, `location`, and effective policies.
  2) Validate `event_type`, quantity sign and units; normalize to `qty_base`.
  3) For `COUNT_ADJUST`: compute `delta = desired_on_hand − current_on_hand` and post delta.
  4) For `TRANSFER_OUT`: post negative at source; `TRANSFER_IN`: post positive at destination (two entries, linked via same `source_doc`).
  5) For `CONSUMPTION`/`WASTE`: post negative `qty_base` with required `reason` in `source_doc`.
  6) For `RECEIPT`: post positive `qty_base` with `cost_per_base` for valuation.
  7) For `MOVE_OUT`/`MOVE_IN`: use for checkout/checkin workflows on assets.
  8) Insert row to `inventory_txn` (append-only). Do not update/delete.
  9) Update projections for affected `(item_id, location_id[, lot_id])`.

- Reservation algorithm
  - Hold: insert `reservation` with `status='HELD'`; reduce `availability` but do not change `on_hand`.
  - Release: set `status='RELEASED'` (or delete if policy allows). Fulfill on checkout by recording `MOVE_OUT` and marking reservation `FULFILLED`.
  - Availability: sum of overlapping reservations within `[start_ts, end_ts]` windows.

- Valuation (rolling average, initial)
  - On `RECEIPT`: update `avg_cost` as `(prev_qty*prev_avg + received_qty*received_cost) / (prev_qty + received_qty)`.
  - On negative movements: COGS uses current `avg_cost`. Store COGS reference in `inventory_txn.cost_per_base` or `source_doc`.

Files (server)
- New: `server/src/services/inventory/postTransaction.ts`, `reservations.ts`, `items.ts`, `projections.ts`
- Update: export functions from index barrel if created.

---

### API Endpoints (Phase 2B)

Add a dedicated route group under `/api/v1/inventory` with auth.

- Mount point in `server/src/api.ts`
  - Create `inventoryRoutes` (new module or inline route group) and mount with `api.route('/inventory', inventoryRoutes)` under the existing `api` that is mounted at `/api/v1`.
  - Use `authMiddleware` for all inventory routes.

- Endpoints
  - `GET /api/v1/inventory/items` — list with filters: `q`, `item_type`, `department_id`, `active`
  - `POST /api/v1/inventory/items` — create item with `schema_id` and `attributes`
  - `GET /api/v1/inventory/items/:itemId` — fetch detail + current on-hand/availability summary
  - `PATCH /api/v1/inventory/items/:itemId` — update mutable fields (`name`, `base_unit`, `attributes` with schema validation)
  - `GET /api/v1/inventory/locations` — list locations (filter by `department_id`)
  - `POST /api/v1/inventory/transactions` — post ledger entry; supports `TRANSFER` (source/destination), `COUNT_ADJUST`, etc.
  - `GET /api/v1/inventory/transactions` — query by `item_id`, `location_id`, `event_type`, `ts range`
  - `POST /api/v1/inventory/reservations` — create hold for `(item, location, event_id, window)`
  - `PATCH /api/v1/inventory/reservations/:resId` — release/fulfill
  - `GET /api/v1/inventory/reservations` — list, filter by `event_id`/`item_id`

Files (server)
- Update `server/src/api.ts` to define and mount the route group, leveraging service layer functions.

---

### UI (Phase 3)

Add an Inventory section to the app with list/detail, transactions, and reservations.

- Navigation and routes
  - Update `ui/src/components/appSidebar.tsx` to add a link to `/inventory`.
  - Update `ui/src/App.tsx` to add routes:
    - `/inventory` — summary dashboard (cards: On-hand, Availability, Recent Transactions)
    - `/inventory/items` — items list (search, filters)
    - `/inventory/items/:itemId` — item detail (attributes, on-hand by location/lot, activity)
    - `/inventory/transactions/new` — post transaction wizard (supports units and conversions)
    - `/inventory/reservations` — holds list with actions

- API client
  - Extend `ui/src/lib/serverComm.ts` with functions: `listInventoryItems`, `createInventoryItem`, `getInventoryItem`, `patchInventoryItem`, `listInventoryLocations`, `postInventoryTransaction`, `listInventoryTransactions`, `createReservation`, `listReservations`, `updateReservation`.

- Components (ShadCN/Tailwind)
  - Use existing primitives; add new charts/tables if needed via `npx shadcn add`.
  - New components under `ui/src/features/inventory/`: `ItemForm`, `TransactionForm`, `ReservationPanel`, `OnHandTable`.
  - Reuse existing `date-field.tsx`, `time-field.tsx`, `calendar.tsx`, `popover.tsx` for scheduling-style pickers.

State & UX
- Accept grouped inputs like “2 cases + 3 bottles”; convert to `qty_base` via unit conversions fetched from API.
- Warn on policy violations (e.g., missing reservation for assets).
- For bar (consumables/perishables), show par-level indicators per `location`.

---

### Department Specifics & Policies (Phase 4)

- Start with two attribute schemas and baseline policies (as in the brief):
  - `Bar.Consumable.v1` — lots/expiry, par levels per `location`, recipe/pour metadata
  - `Production.ReturnableAsset.v1` — serials, service intervals, inspection checklists, kit BOM refs
- Policies
  - Keys to support initially: `requires_reservation` (bool), `count_frequency_days` (int), `valuation_method` (`avg`/`fifo`), `par_levels` (jsonb per location), `allowed_event_types` (string[])
- Kits/BOMs
  - Model kits as `item_type='Kit'` with a BOM table (future phase). On reservation or checkout, expand to component reservations/transactions.

---

### Non-functional & Security

- Immutability: block UPDATE/DELETE on `inventory_txn` at DB level (trigger) and in service layer.
- Auditing: include `posted_by` from auth context; capture `source_doc` with reason codes for adjustments/waste.
- Performance: indexes above; batch projection updates in a transaction after ledger insert.
- RLS: future; start with service-layer auth and department scoping.

---

### File and Change Map

- Server
  - Create migrations: `server/drizzle/0009_inventory_core.sql`, `server/drizzle/0010_inventory_projections.sql`
  - Create schema modules under `server/src/schema/inventory/*` and export from `server/src/schema/index.ts`
  - Add services under `server/src/services/inventory/*`
  - Update `server/src/lib/validators.ts` with inventory validators
  - Update `server/src/api.ts` to mount `/api/v1/inventory` routes (protected)

- UI
  - Update `ui/src/components/appSidebar.tsx` to add Inventory entry
  - Update `ui/src/App.tsx` to add Inventory routes
  - Extend `ui/src/lib/serverComm.ts` with inventory client functions
  - Add pages/components under `ui/src/features/inventory/*` and `ui/src/pages/Inventory*.tsx`

---

### Rollout Plan

1) Phase 1 — Data layer: migrations + Drizzle schema + basic projections; verify via temporary admin endpoints and `GET /api/v1/health`.
2) Phase 2A — Services/algorithms: posting, reservations, projections update, valuation avg cost.
3) Phase 2B — API routes: items, transactions, reservations, locations.
4) Phase 3 — UI: navigation, pages, forms, and tables.
5) Phase 4 — Department policies, bar/production UX, POS/checkout flows, BOMs/kits.

Environment
- Backend requires `DATABASE_URL` (Neon or local). Frontend uses `VITE_API_URL` (already in `ui/src/lib/serverComm.ts`).


