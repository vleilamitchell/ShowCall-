Employee Scheduling: Shift Assignments with Constraints (Greedy+Swap and ILP)

Context

- We need to produce employee-to-shift assignments that respect availability, skills/roles, lead coverage, hour caps/rest, and coverage requirements, while maximizing a consistent score used by both an ILP (gold standard) and a fast greedy+swap heuristic.
- Current model has `employees`, `positions`, `employee_positions` with per-(employee,position) `priority` (0.0–9.9 UI; stored int tenths) and `isLead`, `events` with `priority` (1–5), `shifts` linked to events, and `assignments` that tie a `shift` to a `requiredPositionId` with an optional `assigneeEmployeeId`.
- We will add missing data to express coverage needs and constraints, implement a scheduling service with both solvers, expose APIs to run/preview/commit schedules, and a UI preview to apply or tweak.

Objective/Scoring (shared by ILP and heuristic)

- For a candidate assignment of employee e to shift s (for event k) with required position r and department d, define:
  - P_e = prio[e,r,d]/9.9 (normalize the existing `employee_positions.priority`)
  - W_k = evtprio[k]/5 (normalize `events.priority`)
  - U(e,s) = W_k * ( α * P_e + β * LeadBonus(e,s) ) - γ * Fatigue(e,s) - δ * Unfairness(e)
  - Typical weights: α=1.0, β=0.3, γ=0.2, δ=0.1 (configurable per department)
  - LeadBonus = 1 if the requirement needs a lead and e has `isLead`; otherwise 0 (optionally a small bonus when not required).
  - Fatigue accounts for short-turnaround risk or total hours this week.
  - Unfairness penalizes deviation from target weekly hours or premium-shift counts.

Hard constraints

- Employee must be eligible: mapped to the required position (`employee_positions` join exists) and available in the window
- One-at-a-time: no overlapping shifts per employee
- Coverage: each shift requirement must assign exactly `needCount` employees
- Lead coverage: where required, at least one lead on that requirement
- Legal rest and max hours limits respected

Relevant existing files and modules

- Server schema: `server/src/schema/{employees.ts, positions.ts, employeePositions.ts, events.ts, shifts.ts, assignments.ts}`
- Assignments API: `server/src/routes/assignments.ts`, `server/src/services/assignmentsService.ts`, `server/src/controllers/assignmentsController.ts`
- Shifts/Event APIs: `server/src/routes/shifts.ts`, `server/src/controllers/eventsController.ts`, `server/src/repositories/eventsRepo.ts`
- Schedules shell: `server/src/routes/schedules.ts`, `server/src/services/schedulesService.ts`
- UI: `ui/src/pages/Scheduling.tsx` (shift drawer shows AssignmentsPanel), `ui/src/features/positions/PositionAssignments.tsx`, `ui/src/lib/serverComm.ts`

Planned data model additions (Phase 1 – Data layer)

1) Shift requirements (coverage targets per position)
   - New table `shift_requirements` (Drizzle):
     - id (pk), shiftId (fk → shifts, cascade), departmentId (fk → departments)
     - requiredPositionId (fk → positions)
     - needCount (int, >=1)
     - leadRequired (boolean, default false)
     - areaId (nullable fk → areas) for per-area needs
     - unique index on (shiftId, requiredPositionId, areaId) to coalesce duplicate requirements
   - Purpose: expresses coverage and lead need; replaces creating placeholder `assignments` rows just to represent needs.

2) Employee availability and limits
   - New table `employee_availability`:
     - id, employeeId, departmentId
     - day (ISO date) or rule type (weekly pattern), startTime, endTime; optional recurrence rule stored as text for now
   - New table `employee_limits`:
     - id, employeeId, departmentId, maxHoursPerWeek (int minutes or hours), minRestMinutes (int), targetHoursPerWeek (int), effectiveFrom (date)
   - These tables support feasibility and fairness (Fatigue/Unfairness) without embedding policy into code.

3) Scheduling runs (metadata and determinism)
   - New table `scheduling_runs`:
     - id, departmentId, scheduleId or eventId, algorithm (heuristic|ilp), rngSeed, startedAt, finishedAt, objective, status, params (json), diffs (json)
   - Store previewed results and allow replay with the same seed.

4) Minor additions
   - `events.priority` already exists (int). We will treat [1–5]. If null, default to 3 at scoring time.
   - No change to `employee_positions`: we already have per-(employee,position) priority (tenths) and `isLead` flag.
   - Keep `assignments` as the persisted ground truth of who is assigned to which requirement instance (we will write assignments upon commit).

APIs to add/extend (Phase 2A – API)

- Scheduling router `server/src/routes/scheduling.ts` (new):
  - POST `/api/v1/scheduling/run`
    - Body: { departmentId, scheduleId? | eventId?, algorithm?: 'heuristic'|'ilp', rngSeed?: string, weights?: { alpha, beta, gamma, delta } }
    - Behavior: loads shifts in window, joins requirements, filters employees by eligibility and availability, runs selected algorithm, stores a `scheduling_runs` row and returns a preview payload
    - Response: { runId, objective, assignments: Array<{ shiftId, requiredPositionId, areaId?, assigneeEmployeeId }>, diffs: { created: n, changed: n, removed: n } }
  - POST `/api/v1/scheduling/commit`
    - Body: { runId } or { departmentId, scheduleId? | eventId?, result }
    - Behavior: Upserts `assignments` to match the result, deletes surplus, returns counts
  - GET `/api/v1/scheduling/explain`
    - Query: { departmentId, shiftId }
    - Behavior: returns candidate list and U(e,s) components for debug (score breakdowns per candidate)

- Requirements CRUD `server/src/routes/shiftRequirements.ts` (new):
  - GET `/departments/:departmentId/shifts/:shiftId/requirements`
  - POST `/departments/:departmentId/shifts/:shiftId/requirements`
  - PATCH `/shift-requirements/:id`
  - DELETE `/shift-requirements/:id`

- Extend Assignments checks
  - Keep existing confirmation endpoints. Before publishing a shift, ensure all requirement rows have `needCount` satisfied by counted `assignments` for that (shiftId, requiredPositionId, areaId) and, where `leadRequired`, at least one assigned `employee_positions.isLead = true`.

Server implementation plan (files/functions)

- Schema (Drizzle) new files:
  - `server/src/schema/shiftRequirements.ts`
  - `server/src/schema/employeeAvailability.ts`
  - `server/src/schema/employeeLimits.ts`
  - `server/src/schema/schedulingRuns.ts`

- Migrations: `server/drizzle/*` to create tables + indexes; update `server/src/schema/index.ts` to export.

- Services (new folder `server/src/services/scheduling/`):
  - `score.ts`: compute U(e,s)
    - `computeAssignmentScore(params: { employee, position, shift, event, weights, leadRequired, hoursToDate, restWindows }) → number`
  - `feasibility.ts`: eligibility and constraint checks
    - `listEligibleCandidates(departmentId, requirementId) → Employee[]`
    - `hasOverlap(assignments, employee, shift) → boolean`
  - `heuristic.ts`: greedy+swap per BRIEF_0006
    - Precompute candidates and scores
    - Order shifts by (-W_k, rarity, leadRequired first, earliest start)
    - Greedy fill by best score, breaking ties by lower assigned hours then higher P_e
    - Improvement loop with single swap, pair swap, limited reflow, annealing with cooling (200–1000 iters), fairness polish
    - Deterministic RNG seed and stable tie-breakers on (employee_id, shift_id)
  - `ilp.ts`: build and solve ILP model
    - Binary x_{e,s}; constraints: coverage, availability/skills, one-at-a-time, lead coverage, hours cap; objective ∑ U(e,s) x_{e,s}
    - Implement via optional dependency (e.g., ortools) guarded by env flag; otherwise no-op or use CP-SAT in service tier only (nightly)
  - `run.ts`:
    - `runScheduling({ departmentId, scheduleId|eventId, algorithm, rngSeed, weights }) → { objective, result }`
    - Writes `scheduling_runs` and returns preview

- Routes/Controllers:
  - `server/src/routes/scheduling.ts` → controllers in `server/src/controllers/schedulingController.ts`
  - `server/src/routes/shiftRequirements.ts` → `server/src/controllers/shiftRequirementsController.ts`
  - Wire into `server/src/routes/index.ts`

- Reuse existing repos where possible:
  - `eventsRepo.listShiftsByEventId`, `assignmentsService`, `employeePositionsRepo`

UI plan (Phase 2B – UI)

- `ui/src/pages/Scheduling.tsx`
  - Add an “Auto-Assign” button in the shift drawer header (visible when requirements exist)
  - Opens `AssignmentPreviewDialog` showing current vs proposed per requirement with score deltas and coverage status
  - Buttons: Apply changes, Regenerate (new seed), Export CSV

- New component `ui/src/components/AssignmentPreviewDialog.tsx`
  - Props: { departmentId, scheduleId|eventId, preview, onApply }
  - Table grouped by shift → requirement; each row shows candidate chosen and a change badge; rows clickable to open `assignment-picker` for manual override before apply

- `ui/src/lib/serverComm.ts`
  - Add: `runScheduling`, `commitScheduling`, `listShiftRequirements`, `createShiftRequirement`, `updateShiftRequirement`, `deleteShiftRequirement`

Test-first plan (write these before implementation)

- Unit tests (server, vitest):
  - `services/scheduling/score.test.ts`
    - P_e and W_k normalization, weight applications
    - LeadBonus behavior when requirement is leadRequired and employee `isLead`
    - Fatigue penalty increases with hours; Unfairness penalizes deviation from target
  - `services/scheduling/heuristic.test.ts`
    - Greedy ordering by (-W_k, rarity, leadRequired, start)
    - Greedy respects one-at-a-time and coverage
    - Swap/anneal improves or equals baseline; deterministic with seed
  - `services/scheduling/feasibility.test.ts`
    - Availability window checks, overlap detection, lead coverage validation

- Integration tests (server):
  - `routes/scheduling.run.test.ts`
    - Given department with sample shifts, requirements, and employees/limits, `POST /scheduling/run` returns full coverage and objective > 0; idempotent with same seed
  - `routes/scheduling.commit.test.ts`
    - Applying preview writes `assignments` rows, publish guard in `routes/shifts.ts` recognizes full confirmation
  - `routes/shiftRequirements.test.ts` CRUD and enforcement of unique (shiftId, requiredPositionId, areaId)

- UI tests (component-level):
  - `AssignmentPreviewDialog` renders changes and calls `commitScheduling`
  - `Scheduling.tsx` shows “Auto-Assign” only when requirements exist

Algorithms (step-by-step)

Heuristic
1. Candidate build: For each requirement, filter employees by department, position eligibility (`employee_positions`), availability, hours caps/rest prelim checks; compute U(e,s)
2. Ordering: Sort requirements by (-W_k, candidate count ascending, leadRequired first, earliest shift start)
3. Greedy fill: For each, pick top candidates by score; tie-break on lower assigned hours then higher P_e; enforce non-overlap and caps
4. Improvement loop: iterate 200–1000 times with deterministic RNG; try single and pair swaps; limited reflow (Kempe-chain style) on stuck high-priority slots; accept uphill with cooling; track best objective
5. Fairness polish: post-pass to reduce hours variance without reducing objective materially

ILP
- Variables x_{e,s} ∈ {0,1}; maximize ∑_{e,s} U(e,s) x_{e,s}
- Constraints: coverage (exact `needCount`), availability/skills (disallow infeasible edges), one-at-a-time, lead coverage (≥1 lead per leadRequired), hours cap, rest windows
- Use slack with big-M only if we decide to permit underfill when impossible; otherwise exact cover and report infeasible

Configuration and env

- Department-scoped weights and solver selection stored in DB or `.env` overrides:
  - `SCHEDULER_DEFAULT_ALGORITHM=heuristic|ilp`
  - `SCHEDULER_HEURISTIC_ITERS=500`
  - `SCHEDULER_ENABLE_ILP=true|false`

File-by-file changes needed

- Add schemas: `shiftRequirements.ts`, `employeeAvailability.ts`, `employeeLimits.ts`, `schedulingRuns.ts` and export from `server/src/schema/index.ts`; add migrations in `server/drizzle/`
- Add services: `server/src/services/scheduling/{score.ts,feasibility.ts,heuristic.ts,ilp.ts,run.ts}`
- Add routes/controllers: `server/src/routes/{scheduling.ts, shiftRequirements.ts}`, `server/src/controllers/{schedulingController.ts,shiftRequirementsController.ts}`; mount in `server/src/routes/index.ts`
- Extend `routes/shifts.ts` confirmation check to use requirements coverage rather than raw count of `assignments` rows
- UI: add `ui/src/components/AssignmentPreviewDialog.tsx`; extend `ui/src/pages/Scheduling.tsx`; extend `ui/src/lib/serverComm.ts`

Out-of-scope and assumptions

- We assume weekly hours/fairness are department-local; cross-department fairness is out-of-scope for v1
- ILP is optional; ship heuristic first; ILP can run in batch/nightly
- Availability recurrence is stored as text for now; a richer RRULE editor is future work

Phasing

- Phase 1 (Data layer): schemas + migrations + CRUD for `shift_requirements`; seed some test data
- Phase 2A (API): scheduling service (heuristic only), run/commit/explain endpoints
- Phase 2B (UI): preview dialog and apply flow; integrate with existing AssignmentsPanel
- Phase 3 (Optional): ILP implementation behind flag, nightly batch job wiring

Notes mapping BRIEF_0006 to our model

- Employee priority (0.0–9.9 UI) is already present in `employee_positions.priority`; we normalize to P_e ∈ [0,1]
- Event priority (1–5) exists on `events.priority`; normalize to W_k ∈ [0,1]
- Lead flag is `employee_positions.isLead`; requirement adds `leadRequired`
- Coverage is encoded by `shift_requirements.needCount`; assignments must meet this exactly per requirement
- Determinism: we include `rngSeed` on each run and stable tie-breakers based on (employee_id, shift_id)

Deliverables

- Migrations for new tables
- Server scheduling module with heuristic, preview endpoints, and commit path
- UI preview/apply workflow connected to existing scheduling page
- Tests (unit + integration + UI) written and passing before enabling feature toggle


