## Feature: CI/CD to Testing Platform using reused showcall_v1 workflows

### Context
- We need to start deploying this repo (`showcall/`) to a testing platform.
- `showcall_v1/` contains two GitHub Actions for an older Postgres-backed system:
  - `.github/workflows/api-deploy.yml` (Azure Web App for API)
  - `.github/workflows/web-deploy.yml` (Azure Static Web Apps for frontend)
- Goal: Reuse that infrastructure unless increased capacity/instances are needed.
- Current stack: React (Vite) + Tailwind + ShadCN (ui/), Hono API (server/), Drizzle + Postgres, Firebase Auth, pnpm monorepo.

### High-level approach
- Replicate showcall_v1 workflows into this repo with path, toolchain, and secrets alignment.
- Target a single "dev" testing environment first; parameterize for future staging/prod.
- Ensure monorepo layout (root/ui/server) and pnpm are handled in each workflow.
- Define required secrets in GitHub and environment variables in Azure resources.

### Files to add/change
- Add workflows under `.github/workflows/` in this repo:
  - `api-deploy.yml`
  - `web-deploy.yml`
- Verify/adjust build scripts:
  - `server/package.json`: ensure `build` or deploy script exists for artifact used by Azure deploy (or Cloudflare alternative). Currently has `deploy:cf`; we will add an Azure build output if reusing Azure.
  - `ui/package.json`: `build` already outputs to `ui/dist`.
- Optional infra docs: `docs/deployment/azure.md` (not required for this plan).

### Detailed design: API workflow (reusing showcall_v1 api-deploy.yml)
- Trigger:
  - on push to `main`
  - path filters for `server/**` and the workflow file
- Runner: `ubuntu-latest`
- Node: 22.x
- Cache: pnpm
- Steps:
  1) Checkout
  2) Setup Node 22 with pnpm caching
  3) Install dependencies in `server/` using pnpm
  4) Build API (produce deployable artifact)
  5) (If needed) `pnpm prune --prod` or `pnpm deploy` style artifact prep
  6) Azure login via OIDC
  7) Deploy to Azure Web App using Zip Deploy
  8) Post-deploy health check against `${{ secrets.API_BASE_URL }}/health`

- Path and toolchain adaptations from showcall_v1:
  - Replace `src/server/` with `server/`
  - Replace `npm ci` with `pnpm install --frozen-lockfile`
  - Replace `npm run build` with an added `build` script in `server/package.json` that builds to `dist/` (we will add this script: `"build": "tsx build src/server.ts"` or a tsconfig-driven emit).
  - Prepare zip from `server/` folder; include `package.json`, `pnpm-lock.yaml`, `dist`, and `node_modules` (or use `azure/webapps-deploy@v3` with a prebuilt folder).

- Required GitHub repo secrets:
  - `AZURE_CLIENT_ID`
  - `AZURE_TENANT_ID`
  - `AZURE_SUBSCRIPTION_ID`
  - `AZURE_WEBAPP_NAME` (API app service name)
  - `API_BASE_URL` (for health checks)

- Azure App Service configuration (set in Azure, not in repo):
  - App settings for runtime Node 22
  - Environment variables:
    - `DATABASE_URL` (Neon / Supabase / Azure PG)
    - `FIREBASE_PROJECT_ID`
  - Optional slot for testing (staging slot) mapped to this workflow's environment `dev`.

### Detailed design: Web workflow (reusing showcall_v1 web-deploy.yml)
- Trigger:
  - on push to `main`
  - path filters for `ui/**` and the workflow file
- Runner: `ubuntu-latest`
- Node: 22.x
- Steps:
  1) Checkout
  2) Setup Node 22 with pnpm caching
  3) Pre-build API health check against `${{ secrets.API_BASE_URL }}/health` (optional but recommended)
  4) Build web in `ui/` with `pnpm install --frozen-lockfile && pnpm build`
     - Inject envs: `VITE_USE_API=1`, `VITE_API_URL=${{ secrets.API_BASE_URL }}`
  5) Deploy to Azure Static Web Apps using `Azure/static-web-apps-deploy@v1`

- Path and toolchain adaptations:
  - Replace `src/web/` with `ui/`
  - Use pnpm instead of npm
  - Ensure `output_location` is `dist`

- Required GitHub repo secrets:
  - `AZURE_STATIC_WEB_APPS_API_TOKEN`
  - `API_BASE_URL`

### New/updated scripts
- `server/package.json`:
  - Add `build`: produce Node bundle into `server/dist` that Azure runs (if we deploy to Azure App Service). Example options:
    - Use tsx to transpile on the fly (App Service can run TypeScript via tsx), or
    - Add `tsc` build: `"build": "tsc -p tsconfig.json"` with an `outDir` of `dist`.
  - Add `start`: `node dist/server.js` (or equivalent) for Azure.
- If we opt to keep Cloudflare Workers for API in the future, weâ€™d keep current `deploy:cf` untouched and wire a separate workflow; for this testing plan we target Azure to reuse v1 infra.

### Environment and secrets mapping
- GitHub Action secrets (set in repo settings > Secrets and variables > Actions):
  - `AZURE_CLIENT_ID`, `AZURE_TENANT_ID`, `AZURE_SUBSCRIPTION_ID`, `AZURE_WEBAPP_NAME`, `AZURE_STATIC_WEB_APPS_API_TOKEN`, `API_BASE_URL`.
- Azure App Service (API):
  - App settings: `DATABASE_URL`, `FIREBASE_PROJECT_ID`.
- Azure Static Web Apps (Frontend):
  - Use `VITE_API_URL` at build time via Action secrets; no runtime secrets needed.

### Algorithms and sequence
1) On push to `main`, API workflow builds and zip-deploys `server/` to Azure App Service.
   - After deployment, perform health check loop until HTTP 200 or timeout.
2) On success, Web workflow builds `ui/` with `VITE_API_URL` pointing to API base and deploys to Azure Static Web Apps.
3) For first-time setup, run workflows manually via `workflow_dispatch` to validate.

### Rollout phases
- Phase 1 (Data layer readiness):
  - Confirm `server/` can run from built JS with `start` script.
  - Ensure database migrations succeed against testing database (run `pnpm db:push` manually or via release script, non-blocking for CI).
- Phase 2A (API CI/CD):
  - Add/commit `api-deploy.yml` with pnpm and path updates.
  - Add `build` and `start` scripts to `server/package.json`.
  - Validate health endpoint exists at `GET /health` in `server`.
- Phase 2B (Web CI/CD):
  - Add/commit `web-deploy.yml` with pnpm and `ui/` paths.
  - Ensure `ui` builds successfully locally and via CI.

### Implementation checklist
- Add `.github/workflows/api-deploy.yml` adapted for monorepo and pnpm.
- Add `.github/workflows/web-deploy.yml` adapted for monorepo and pnpm.
- Update `server/package.json` with `build` and `start` scripts for Azure.
- Verify health endpoint in `server` (`/health`). If missing, add simple 200 OK.
- Configure GitHub Action secrets.
- Configure Azure App Service settings and Static Web Apps token.

### Notes
- If we later need multiple instances/environments, duplicate workflows with `environment:` set to `staging`/`prod`, distinct Azure resources, and branch/path filters.
- If we decide to switch API to Cloudflare Workers in production, keep Azure testing for parity while introducing a new workflow using `wrangler deploy`; web can continue as Azure Static Web Apps or move to Cloudflare Pages.
