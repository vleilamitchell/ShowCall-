### Redesign the positions area within Department detail

"In the departments view, there is a positions area inside the department detail area. The positions area is awkward right now. Let's redesign it to be beautiful and easy to use and understand. Think deeply about this."

Brief: Replace the current inline positions management UI with a clearer, two-pane assignment experience that scales to large lists, supports fast mapping, reordering, and clean empty/error states, while remaining aligned with existing list-detail patterns and APIs.

Relevant code today
- UI
  - `ui/src/pages/Departments.tsx`
    - `Departments()` uses `ListDetailLayout`, left list of departments; right shows details including positions.
    - `PositionsSection({ departmentId })` renders search/create positions, a list of positions with inline rename/delete, and an expanded panel per position that shows a grid of all employees with a `Switch` to map/unmap plus `priority` and `isLead` controls.
  - `ui/src/features/listDetail/*` used for list + detail patterns.
- Client API helpers: `ui/src/lib/serverComm.ts`
  - Departments: `listDepartments()`, `getDepartment()`, `createDepartment()`, `updateDepartment()`
  - Employees: `listEmployees(departmentId)`, `createEmployee()`, `updateEmployee()`, `deleteEmployee()`
  - Positions: `listPositions(departmentId, { q? })`, `createPosition(departmentId, { name })`, `updatePosition(positionId, patch)`, `deletePosition(positionId)`
  - EmployeePositions: `listEmployeePositions(departmentId)`, `createEmployeePosition(payload)`, `updateEmployeePosition(id, patch)`, `deleteEmployeePosition(id)`
  - Eligibility: `listEligibleEmployeesForPosition(departmentId, positionId)`
- Server API: `server/src/api.ts`
  - Departments routes: `/api/v1/departments` (+ nested employees, positions, employee-positions, and eligibility route)
  - Positions item routes: `/api/v1/positions/:positionId` (PATCH/DELETE)
  - EmployeePositions item routes: `/api/v1/employee-positions` (POST/PATCH/DELETE)

Current UX issues to address
- Mixing creation, listing, and per-position management inline makes the section visually dense and hard to scan.
- Expand/collapse per-position drives large grids of switches with little context (no counts, no quick filters, no bulk actions).
- Reordering via numeric `priority` input is slow and error-prone; lacks drag-and-drop.
- No clear separation between available vs assigned employees; no “unassigned” filter.
- Manage actions are hidden behind the expanded state, hurting discoverability.
- Limited empty and loading states; lack of visual hierarchy.

Proposed UX (high-level)
- Two-pane layout inside the department detail:
  - Left: Positions list with search, counts, and lightweight row actions.
  - Right: Position detail when selected, with tabs for Assignments and Settings.
- Left positions list improvements:
  - Each row shows: position name, a badge with assigned count, and a small lead count badge if any leads.
  - Row actions (via a kebab menu): Rename, Delete. Primary click selects and opens detail.
  - Quick create at the top (inline) and search filter; empty state with guidance.
- Right detail – Assignments tab:
  - Two-column assignment UI:
    - Left column: “Available employees” list with search and filters: All, Unassigned, Assigned.
    - Right column: “Assigned to position” list with drag-and-drop reordering; each chip/row shows name, optional priority index, and a lead toggle.
  - Bulk actions: Add selected, Remove selected; Clear all; Add all unassigned.
  - Eligibility (if available from API) shown beneath assigned list as a compact, sorted panel.
  - Optimistic updates for map/unmap, reorder, and lead toggles.
- Right detail – Settings tab:
  - Rename field with save, Delete position with confirmation.
- Visual design:
  - Use ShadCN `badge`, `switch`, `input`, `button`, `tooltip`, `dropdown-menu`, `scroll-area`, optional `sheet` or `dialog` for confirm.
  - Skeleton states while loading; graceful “No positions” and “No employees yet” messages.

Data flow and algorithms
- Data loading (per department):
  - Fetch in parallel: `listPositions(departmentId)`, `listEmployees(departmentId)`, `listEmployeePositions(departmentId)`.
  - Build `Map<positionId, EmployeePositionRecord[]>` for fast lookup. Keep derived sets:
    - `assignedEmployeeIdsForSelectedPosition`
    - `unassignedEmployees = employees.filter(e => !assignedIds.has(e.id))`
  - When a position is selected, optionally fetch `listEligibleEmployeesForPosition(departmentId, positionId)`.
- Sorting and priority:
  - In UI, display assigned employees ordered by ascending numeric `priority` with nulls at the end. If equal or null, secondary sort by name.
  - On reorder (drag-and-drop), compute new ordered list and generate priority values as 1..N. Prepare a batch payload to update only changed rows.
- Mapping/unmapping:
  - Map: create employee-position with priority = (current assigned length + 1) and `isLead` default false.
  - Unmap: delete employee-position.
  - Bulk add/remove: loop or use a batch endpoint if available (see API additions below). Optimistically update local state and reconcile on response.
- Searching and filtering:
  - Positions search uses existing `listPositions(departmentId, { q })`.
  - Employee search/filter is client-side to start; pagination can be added later if the list is very large.

Planned UI structure (files/functions)
- Replace inline `PositionsSection` in `ui/src/pages/Departments.tsx` with a composed panel:
  - Create `ui/src/features/positions/PositionsPanel.tsx` with `PositionsPanel({ departmentId })`.
  - Create `ui/src/features/positions/PositionList.tsx` for the left list (search, counts, row actions).
  - Create `ui/src/features/positions/PositionDetail.tsx` that renders tabs (Assignments, Settings).
  - Create `ui/src/features/positions/PositionAssignments.tsx` for the two-column assignment UI.
  - Create `ui/src/features/positions/hooks/usePositionsData.ts` to encapsulate loading, mapping, and derived state; expose mutation helpers for map/unmap/reorder/lead.
- If drag-and-drop is introduced:
  - Add `@dnd-kit/core` and `@dnd-kit/sortable` (via `pnpm add`) and wire to `PositionAssignments` for reordering.

API additions (small, optional but recommended)
- Batch update priorities for a single position to support drag-and-drop without N sequential requests:
  - New route: `PATCH /api/v1/positions/:positionId/employee-positions` with body `{ items: Array<{ id: string; priority: number; isLead?: boolean }> }`.
  - Server: in `server/src/api.ts`, add the route under positions or employee-positions; validate all belong to the same positionId and department; update in a single transaction; return updated rows.
  - Client: add `updateEmployeePositionsBatch(positionId, items)` to `ui/src/lib/serverComm.ts`.
- (Optional) Employee list search/pagination:
  - New `GET /api/v1/departments/:departmentId/employees` may accept `q`, `limit`, `cursor` (non-breaking since current implementation returns all). For now, plan client-side filtering; keep server unchanged unless needed.

Edge cases
- Large lists: virtualize scroll areas; avoid rendering all employees inside each expanded card; only render detail for the selected position.
- Concurrency: when multiple edits occur, prefer optimistic updates with refetch-on-settle; guard against duplicate mappings via server unique index on `(department_id, employee_id, position_id)` (already present).
- Deletes: deleting a position should also remove its employee-position rows (server already deletes by id only; we won’t cascade in DB here, but UI will visually clear assigned list after a successful delete).
- Leads: schema allows multiple leads per position (`is_lead boolean`). Keep toggle semantics; a single-lead constraint can be added later if needed.

Implementation steps
1) UI scaffolding
   - Create new `ui/src/features/positions/*` components listed above.
   - Swap `PositionsSection` usage in `ui/src/pages/Departments.tsx` to `PositionsPanel`.
   - Add ShadCN components if missing: `badge`, `dropdown-menu`, `tooltip`, `sheet`, `skeleton`, `scroll-area` (`npx shadcn add ...`).
2) Assignment UX
   - Implement two-column Assignments with search/filter and bulk actions.
   - Implement optimistic map/unmap using existing endpoints; reconcile on settle.
   - Add counts to the left list rows based on `employeePositions` map.
3) Reordering with priorities
   - Integrate drag-and-drop in the assigned list.
   - Compute new `priority` values on drop and apply via sequential PATCH calls initially, then switch to batch when available.
4) Eligibility panel
   - On position select, fetch eligibility and display below assigned list, sorted by `priority` desc then name (matches existing server-side sort behavior).
5) Optional API batch endpoint
   - Server: add `PATCH /api/v1/positions/:positionId/employee-positions` transactional batch update.
   - Client: add `updateEmployeePositionsBatch` and update reordering logic to use it.
6) Polish
   - Empty/loading states, error toasts, confirmation for destructive actions.
   - Keyboard navigation: arrow keys in lists, Enter to add/remove, Space to toggle lead.
   - Basic a11y roles and labels.

No database migrations
- Existing tables `positions` and `employee_positions` with `priority` and `is_lead` fields are sufficient.

Testing considerations
- Unit: data hook (`usePositionsData`) derives assigned/unassigned correctly; reorder produces expected priority sequences; bulk add/remove produce expected payloads.
- Integration: mapping/unmapping flows, drag reorder optimistic updates, delete position clears UI, counts stay accurate.
- E2E happy paths: create position → assign employees → reorder → toggle leads → delete position.


