### 0032 PLAN — Optimize Schedules page loads (Schedules.tsx)

**Context**

- The request: “optimize the page loads on `Schedules.tsx` — right now when a user clicks on a schedule to see its details the loading of shifts is far from optimal.”
- Today, `ui/src/pages/Schedules.tsx` loads shifts via `api.listAllShifts` and then issues multiple follow-up network calls per department and per event to load employees, positions, event details/areas, and per-shift assignments. This N+1 pattern causes slow, choppy page loads.

### Goal

- Replace many sequential client requests with a single aggregated server payload for schedule detail to drastically reduce network round-trips and render the detail panel quickly and consistently.

### Scope of Changes (files/functions)

- Server
  - `server/src/controllers/eventsPageController.ts`
    - Ensure/complete `scheduleDetail(c)` controller that returns an aggregated payload for a given `scheduleId` and optional `departmentId`.
    - Returned shape detailed below.
  - `server/src/routes/bootstrap.ts`
    - Register new route: `GET /bootstrap/schedule-detail` → `eventsPageController.scheduleDetail`.
  - (No breaking changes) Keep existing `shifts` and `assignments` endpoints as-is for other pages.

- UI
  - `ui/src/lib/serverComm.ts`
    - Add `getScheduleDetail(params: { scheduleId: string; departmentId?: string }): Promise<ScheduleDetailPayload>` that calls `/bootstrap/schedule-detail`.
    - Add `export type ScheduleDetailPayload` to model the aggregated response.
    - Keep `listAllShifts` et al for other screens.
  - `ui/src/pages/Schedules.tsx`
    - Replace the current cascade of calls inside `ScheduleDetail` with a single call to `api.getScheduleDetail`.
    - Locally compute `assignedByShift` from the aggregated payload (no extra network calls).
  - (Optional for testability) `ui/src/pages/Schedules.utils.ts`
    - Extract a pure function to derive `assignedByShift` from the aggregated payload for unit testing.

### API Contract (new bootstrap endpoint)

- Path: `GET /bootstrap/schedule-detail`
- Query params:
  - `scheduleId` (required)
  - `departmentId` (optional)
- Response (ScheduleDetailPayload):
  - `schedule`: the schedule record
  - `shifts`: `ShiftRecord[]` for the schedule, optionally filtered by department
  - `assignments`: all `AssignmentRecord[]` for the returned shift set
  - `employeesByDept`: `{ [departmentId: string]: Array<{ id: string; name: string }> }`
  - `positionsByDept`: `{ [departmentId: string]: Array<{ id: string; name: string }> }`
  - `areasByEvent`: `{ [eventId: string]: Array<{ id: string; name: string; description?: string; color?: string; active?: boolean; updatedAt?: string }>} `

Notes:
- The controller should batch fetch assignments by the returned `shiftIds` and fetch employees/positions per unique department and areas per unique event. It should sort shifts by `date`, `startTime` on the server.
- Auth must continue to apply via existing `authMiddleware` on the bootstrap router.

### UI Data Flow (after change)

1. `ScheduleDetail` detects a `schedule` selection and calls `api.getScheduleDetail({ scheduleId, departmentId })`.
2. The endpoint returns the aggregated payload in a single round-trip.
3. Build local maps:
   - `employeeNameByDeptAndId[deptId][employeeId]`
   - `positionNameByDeptAndId[deptId][positionId]`
   - `areaNameByEventAndId[eventId][areaId]`
   - `assignmentsByShiftId[shiftId]` by grouping `assignments` by `shiftId`
4. Derive `assignedByShift[shiftId] = Array<{ areaName?: string; positionName?: string; employeeName?: string }>` using the maps above.
5. Render the detail list exactly as today, but without additional fetches.

### Tests (define before implementation)

- Server (vitest)
  - File: `server/src/controllers/__tests__/bootstrap.scheduleDetail.test.ts`
  - Cases:
    - Returns 400 without `scheduleId`.
    - Returns 404 for unknown `scheduleId`.
    - Returns `{ schedule, shifts, assignments, employeesByDept, positionsByDept, areasByEvent }` for valid `scheduleId`.
    - Applies `departmentId` filter: shifts are restricted; employees/positions maps only include relevant departments; assignments only for returned shifts; areasByEvent for only events referenced by returned shifts.
    - Shifts are ordered by `date`, `startTime` ascending.

- UI (vitest)
  - File: `ui/src/pages/__tests__/Schedules.utils.test.ts`
  - Test the pure transform from `ScheduleDetailPayload` to `assignedByShift`:
    - Correctly groups assignments by `shiftId`.
    - Resolves `employeeName`, `positionName`, and `areaName` using the provided maps.
    - Handles missing/undefined references gracefully (falls back to `undefined`).
  - (Optional) Component test with mocked `api.getScheduleDetail` verifying a single call is made and the list renders expected strings.

### Implementation Steps (no code)

Server
- Wire the route in `server/src/routes/bootstrap.ts`: `bootstrapRouter.get('/schedule-detail', ctrl.scheduleDetail);`
- Complete/verify `scheduleDetail` in `server/src/controllers/eventsPageController.ts`:
  - Fetch schedule by `id`.
  - Query `shifts` by `scheduleId` (and `departmentId` when provided), sort ASC by `date`, `startTime`.
  - Build `shiftIds`, `eventIds`, `departmentIds` from those shifts.
  - Fetch `assignments` for `shiftIds` in a single call.
  - Fetch employees and positions for `departmentIds` and shape as described.
  - Fetch event areas for `eventIds` and shape as described.
  - Return the aggregated JSON.

UI
- Add `getScheduleDetail` + `ScheduleDetailPayload` to `ui/src/lib/serverComm.ts` and export via `api`.
- Update `ui/src/pages/Schedules.tsx` `ScheduleDetail` effect:
  - Replace calls to: `listAllShifts`, N×`listEmployees`, N×`getEvent`, N×`getEventAreas`, N×`listPositions`, per-shift `listAssignments`.
  - Make a single call to `api.getScheduleDetail` and compute the maps/`assignedByShift` locally.
- Extract the transform helper to `Schedules.utils.ts` and unit test it.

### Algorithmic Details (server)

- Shifts query:
  - If `departmentId` provided: `WHERE schedule_id = :scheduleId AND department_id = :departmentId` else `WHERE schedule_id = :scheduleId`.
  - `ORDER BY date ASC, start_time ASC`.
- Assignments:
  - Single repo/service call by `shiftIds` with `IN (...)`.
- Employees/Positions:
  - For each unique `departmentId`, query minimal columns and return `{ id, name }` for each list.
- Areas:
  - Query areas for unique `eventIds` and return `{ id, name, description, color, active, updatedAt }`.

### Performance Acceptance

- Network: Replace 1 + N_depts + N_events + N_shifts calls with 1 call.
- Perceived detail-pane load time target: < 300ms on local dev, < 800ms on typical staging.
- UI must not issue additional network calls after the initial aggregated fetch when rendering the schedule detail.

### Backward Compatibility / Risks

- Existing endpoints (`/api/v1/shifts`, per-dept `assignments`, etc.) remain unchanged.
- Only `Schedules.tsx` is refactored to use the new endpoint; other screens continue as-is.
- Ensure auth on `/bootstrap/schedule-detail` via existing bootstrap router middleware.

### Rollout / Toggle

- Ship the new endpoint and UI changes together; no feature flag required.
- If needed, keep a quick revert path by retaining the old client-side code behind a short-lived local flag.


