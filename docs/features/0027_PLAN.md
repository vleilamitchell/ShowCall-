## Feature 0027 — API Refactor: Decompose the Monolith Into Modular, Testable Layers

Brief context: The current API is concentrated primarily in `server/src/api.ts` with a very large router, mixed concerns (routing, validation, business logic, persistence), and ad-hoc patterns per domain. We will refactor to a layered, modular structure with clear boundaries: route → controller → service → repository (Drizzle), plus shared middleware, validation, and error handling. We will do this incrementally using a “strangler” approach, migrating one domain at a time without breaking `/api/v1` clients.

Key files today (sampling):
- `server/src/server.ts`: Node server bootstrap.
- `server/src/api.ts`: Monolithic Hono app creation and most routes (health, protected, events, areas, departments, inventory, addresses, etc.).
- `server/src/middleware/auth.ts`: Firebase auth middleware; sets `c.set('user', user)`.
- `server/src/lib/db.ts`: Drizzle connection management, Neon or local Postgres, simple health checks.
- `server/src/lib/env.ts`: Env accessors/context.
- `server/src/lib/validators.ts`: Common validators/normalizers for emails, phdone, state/zip, dates/times, colors, recurrence.
- `server/src/routes/eventSeries.ts`: Already extracted domain routes.
- `server/src/services/*`: Some domains (e.g., inventory) already use service-style modules.
- `server/src/schema/*` + `server/src/schema/index.ts`: Drizzle table definitions.

High-level goals:
- Consolidate cross-cutting concerns (errors, logging, auth, request context) in middleware and utils.
- Standardize route shapes (query, pagination, error payloads) and validation.
- Move business logic into services; keep controllers thin; repositories encapsulate Drizzle queries.
- Preserve `/api/v1` with zero breaking changes during migration; use strangler pattern to incrementally move endpoints.
- Achieve testability at unit (services) and integration (routes) levels.

Target architecture (directories and responsibilities):
- `server/src/app.ts` — builds and configures the Hono app (cors, logger, error/notFound handlers, base routers), no domain logic.
- `server/src/routes/` — domain routers; one file per domain (e.g., `events.ts`, `areas.ts`, `departments.ts`, `employees.ts`, `inventory/items.ts`, `inventory/transactions.ts`, `inventory/reservations.ts`, `addresses.ts`, `auth.ts`, etc.). Each route only coordinates to a controller.
- `server/src/controllers/` — 1:1 with domain route groups; extract request data, call services; map domain errors → HTTP.
- `server/src/services/` — business logic; orchestrates transactions; depends on repositories and validators. Inventory services already exist and will be aligned to the new conventions.
- `server/src/repositories/` — Drizzle operations per aggregate/table group; accept an explicit `db`/`tx` handle.
- `server/src/validation/` — request DTO schemas and transformations (complementing `lib/validators.ts`). Keep JSON-Schema/Ajv for dynamic attribute schemas; use code-first schemas for DTOs.
- `server/src/middleware/` — `auth`, `requestContext` (request id, timing), `errorHandler` (maps domain errors to HTTP), `rateLimit` (optional later).
- `server/src/http/` — helpers for pagination, query coercion, response envelopes, error shapes.
- `server/src/errors/` — typed error classes (`NotFoundError`, `ValidationError`, `ConflictError`, `AuthError`, etc.) with an error → HTTP mapper.

Versioning and deprecation:
- Keep `/api/v1` as-is. Move handlers behind the same paths in new routers. When a domain finishes migration, remove its legacy handlers from `api.ts`.
- Once all domains migrated, `api.ts` becomes a thin aggregator or is replaced by `app.ts`.

Testing approach (test-first, platformized):
- Establish a project-wide test platform before any refactor begins. This includes runner config, database harness, auth strategy for tests, fixtures, coverage, and CI gating.
- Unit tests target services and validators (no HTTP) and run in isolation with fast in-memory data or transaction-scoped DBs.
- Integration tests exercise routes via Hono’s `app.request()` against an embedded/ephemeral Postgres database with deterministic seed fixtures.
- Golden-master tests are captured on the current monolith to freeze public behavior (status codes, payload shapes, essential fields, and error semantics) for high-risk endpoints before refactors.
- Coverage thresholds gate changes (e.g., statements/branches 80%+ overall and per-changed-file, adjustable if needed), enforced in CI.

Rollout strategy (tests as gates):
- Many small PRs (per-domain or per-resource), each starting by adding or extending tests to capture current behavior, then performing the refactor, keeping all tests green.
- Each PR must include: unit tests for new/changed services, integration tests for migrated routes, and parity assertions versus legacy behavior where applicable.
- Keep feature flags out; rely on endpoint-by-endpoint migration while preserving URLs and semantics, with tests ensuring parity.

---

### Phase T0 — Test Platform Enablement and Golden-Master Capture

Stand up the testing workflow and guardrails that will protect the refactor and enable safe iteration.

Artifacts to add:
- `server/vitest.config.ts` — Vitest config with Node environment, tsconfig alias support, coverage via V8, and per-project watch filters.
- `server/src/test/setup.ts` — global test setup (env loading, timers, matchers, cleanup hooks).
- `server/src/test/testDb.ts` — DB harness: create/reset test database schema, run Drizzle migrations, truncate tables between tests, seed deterministic fixtures.
- `server/src/test/testApp.ts` — `buildTestApp(options)` wrapper around `buildApp()` that can inject a stub auth middleware or emulator-backed auth, and toggles request logging.
- `server/src/test/fixtures/*` — minimal fixtures per domain (addresses, inventory, events, etc.).
- `server/.env.test.example` — document required env vars; real `.env` not committed. Include keys like `DATABASE_URL_TEST` and optional Firebase emulator vars.
- CI config (GitHub Actions or equivalent) to run `pnpm -w test` with coverage and to fail on threshold breaches.

Package scripts (in `server/package.json`):
- `test` → `vitest run`
- `test:watch` → `vitest`
- `test:unit` → `vitest run --dir src --include "**/*.unit.{ts,tsx}"`
- `test:integration` → `vitest run --dir src --include "**/*.int.{ts,tsx}"`
- `test:ci` → `vitest run --coverage`

Environment and infra:
- Add `.env.test` entries the developer must provide: `DATABASE_URL_TEST=postgres://.../showcall_test`, `FIREBASE_AUTH_EMULATOR_HOST=localhost:9099` (optional if using emulator-based auth in tests). Note: do not commit secrets.
- Prefer a dedicated test database (schema per run or fully truncated between files). Use `testDb.ts` to coordinate lifecycle.
- For route tests that require auth, default to a stub auth middleware that injects a synthetic `user` into `c.var` via `buildTestApp({ stubAuth: { userId, email, roles } })`. Emulator-based tests can be added later for end-to-end coverage.

Golden-master pass:
- Before touching production code, add integration tests that hit the highest-risk endpoints (addresses CRUD, inventory transactions/reservations, events/series, and `/protected/me`). Assert on status codes, required fields, ordering, pagination behavior, and canonical error payloads.
- These tests run against the current monolith (`api.ts`) to freeze behavior. Subsequent refactors must keep them green.

Exit criteria:
- Test runner green locally and in CI. Coverage reporting works. A first set of golden-master tests exists for the chosen endpoints and passes against the monolith.

---

### Phase 0 — Scaffolding and Cross-Cutting Infrastructure

Create structure and shared utilities before moving domain code.

Files to add:
- `server/src/app.ts`: create `buildApp()` that sets up Hono, `cors`, `logger`, env context, global `onError`, `notFound`, and mounts base routers. Export the built app for `server.ts`.
- `server/src/errors/index.ts`: define error classes: `AppError` base with `code`, `status`, `details`; subclasses: `ValidationError` (400), `AuthError` (401), `ForbiddenError` (403), `NotFoundError` (404), `ConflictError` (409), `RateLimitError` (429), `InternalError` (500 default). Include a `toHttpResponse()` mapper.
- `server/src/middleware/errorHandler.ts`: Hono middleware to catch thrown `AppError`s and format JSON: `{ error: { code, message, details? } }`.
- `server/src/middleware/requestContext.ts`: attach `requestId` (generate if absent), `startedAt`, and maybe `userId` (if authenticated) to `c.var`.
- `server/src/http/pagination.ts`: parse `limit`, `offset`/`cursor`, default limits, and provide `{ limit, offset }` helpers.
- `server/src/http/query.ts`: helpers to coerce query params to strings, numbers, booleans, arrays; centralize ilike search builder.
- `server/src/http/responses.ts`: helpers to send `{ data, meta }` envelopes; standardized error payloads.
- `server/src/repositories/README.md` (short): repository conventions, receive `dbOrTx`, return plain records.

Testing hooks to wire now:
- Ensure `buildApp()` accepts options for test mode (e.g., `injectAuth`, `disableLogger`) so `testApp.ts` can compose it without reaching into internals.
- Add `withTransaction` in `lib/db.ts` now so service unit tests can use it for atomic test setup/teardown where beneficial.

Files to edit:
- `server/src/server.ts`: import `buildApp()` from `app.ts` and use `serve({ fetch: app.fetch, port })`. Keep CLI arg parsing and DB port logs as-is.
- `server/src/lib/db.ts`: add a `withTransaction<T>(fn)` helper that opens a Drizzle transaction and passes a transaction-scoped `db` to `fn`. Ensure backward compatibility for existing callers.
- `server/src/lib/validators.ts`: no breaking changes. Optionally add `isValidLatitude` and `isValidLongitude` currently used in `api.ts` address handlers.

Algorithms:
1) Global Error Mapping: any thrown `AppError` maps to `{ error: { code, message, details } }` with correct HTTP status.
2) Request Context: generate `requestId` per request, include in logs and error responses.
3) Pagination: clamp `limit` to max (e.g., 100), default 25. Apply standard ordering if none provided.

---

### Phase 1 — Routing Composition and Legacy Adapter

Objective: split app construction from routes, and mount a “legacy” router to keep `api.ts` operating while we migrate.

Files to add:
- `server/src/routes/index.ts`: exports a `mountV1Routers(api: Hono)` that mounts domain routers; initially only mounts `legacyRouter` as a passthrough.
- `server/src/routes/legacy.ts`: wraps or re-exports remaining routes from `api.ts` during migration. After each domain migrates, remove the corresponding handlers from `legacy`.

Files to edit:
- `server/src/api.ts`: extract app creation concerns into `app.ts`; leave only route definitions temporarily. Ultimately retire this file once all routes are migrated.
- `server/src/app.ts`: call `mountV1Routers(api)` and then `app.route('/api/v1', api)`.

Algorithm:
1) `buildApp()` creates `app` and a child `api` router.
2) `mountV1Routers(api)` attaches `legacyRouter` first; new domain routers will mount alongside until legacy routes are removed.

---

### Phase 2 — Authentication and Protected Route Boundary

Files to add/edit:
- `server/src/controllers/authController.ts`: `me()` reads `c.get('user')` and returns profile.
- `server/src/routes/auth.ts`: `GET /protected/me` using `authMiddleware` and `authController.me`.
- `server/src/middleware/auth.ts`: keep as-is; export types for `ContextVariableMap.user` to be reused in controllers.

Algorithm:
1) Ensure all protected routers use `authMiddleware` at the router level (`router.use('*', authMiddleware)`).
2) Keep response shape stable with legacy `me` endpoint.
3) Tests: add golden-master for `GET /protected/me` (unauthenticated → 401, authenticated → 200 with stable shape). Keep green during/after migration.

---

### Phase 3 — Addresses (already partly modularized)

Rationale: Addresses are self-contained and recently added; low-risk to migrate first.

Files to add:
- `server/src/controllers/addressesController.ts` — thin controller mapping request → service DTO.
- `server/src/services/addressesService.ts` — validations, primary-per-role enforcement (handle DB conflicts → `ConflictError`).
- `server/src/repositories/addressesRepo.ts` — Drizzle queries for CRUD and filtered list.
- `server/src/routes/addresses.ts` — mount under `/addresses` with `authMiddleware`.

Files to edit:
- Remove the addresses handlers from `server/src/api.ts` after the new router is mounted and parity tests pass.

Algorithms (step-by-step):
1) Create: normalize inputs (`state`, `zip`), validate lat/long and date ordering, generate id, insert, map conflicts to 409.
2) Patch: selectively validate provided fields; if `isPrimary` toggled to true, rely on unique partial index; map conflicts.
3) List: composable filters (`entityType`, `entityId`, `role`, `status`, `isPrimary`, `q`), order `is_primary DESC, updated_at DESC`.

Tests:
- Unit: validators/normalizers for addresses, service rules for primary-per-role.
- Integration: golden-master parity for legacy endpoints, then new router endpoints. Use fixtures to cover typical and edge cases. Keep behavior identical at the HTTP layer.

---

### Phase 4 — Inventory Domain

Inventory already has `services/inventory/*`. We will align to controller/repository split and standardize requests.

Files to add:
- `server/src/controllers/inventory/itemsController.ts`
- `server/src/controllers/inventory/transactionsController.ts`
- `server/src/controllers/inventory/reservationsController.ts`
- `server/src/repositories/inventory/itemsRepo.ts`
- `server/src/repositories/inventory/transactionsRepo.ts`
- `server/src/repositories/inventory/reservationsRepo.ts`
- `server/src/routes/inventory/items.ts`
- `server/src/routes/inventory/transactions.ts`
- `server/src/routes/inventory/reservations.ts`

Files to edit:
- Align existing services: `server/src/services/inventory/items.ts`, `postTransaction.ts`, `transactions.ts`, `reservations.ts`, `projections.ts` to accept explicit `dbOrTx` and use `withTransaction` where appropriate.
- Remove legacy inventory handlers from `server/src/api.ts` once route parity confirmed.

Algorithms:
1) Post Transaction: run in a single `withTransaction`; write event rows, update materialized views if required; on constraint violations, map to `ValidationError`/`ConflictError`.
2) Reservations: ensure mutual exclusion rules; use `withTransaction` to atomically update holds/releases.
3) Item CRUD: validate attribute schemas via existing Ajv-based `validateItemAttributes()`; cache validators per `schemaId` as today.

Tests:
- Unit: item attribute validation, reservation/transaction rules, projections.
- Integration: end-to-end transaction posting, reservation lifecycles, and list/filters. Golden-master parity first, then route swap retains green.

---

### Phase 5 — Events, Event Areas, Recurring Series

Files to add:
- `server/src/controllers/eventsController.ts`
- `server/src/controllers/eventAreasController.ts`
- `server/src/controllers/recurringSeriesController.ts`
- `server/src/repositories/eventsRepo.ts`
- `server/src/repositories/eventAreasRepo.ts`
- `server/src/repositories/recurringSeriesRepo.ts`
- `server/src/routes/events.ts` (mount `/events`)
- `server/src/routes/eventAreas.ts` (mount `/events/:eventId/areas` or `/event-areas` depending on current paths)

Files to edit:
- Reuse `server/src/routes/eventSeries.ts` by wiring it through controllers/services; or merge into `routes/recurringSeries.ts` with thin controller.
- Remove legacy handlers from `server/src/api.ts` after parity.

Algorithms:
1) Occurrence computation: keep `computeOccurrences` in services; controllers validate inputs and map errors.
2) Upsert series: single transaction to update `eventSeries`, rules, and projected events as today; move direct Drizzle access into repositories.

Tests:
- Unit: occurrence computation edge cases, upsert rules.
- Integration: series CRUD and listing; verify generated occurrences match golden-master expectations.

---

### Phase 6 — Areas, Departments, Employees, Positions, Assignments, Schedules, Shifts, Contacts

Proceed in manageable chunks per PR:
1) Areas → `routes/areas.ts`, `areasController`, `areasRepo`.
2) Departments → `routes/departments.ts`, controller/repo.
3) Employees & Positions → separate controllers/repos; ensure join queries migrate into repositories.
4) Assignments/Schedules/Shifts → ensure all writes that span tables are transactional.
5) Contacts → `routes/contacts.ts`.

For each:
- Add controller, service (if non-trivial), repository, and route modules.
- Move validators to `validation/` if repeated; otherwise keep in `lib/validators.ts`.
- Tests-first: write/extend unit and integration tests capturing current behavior, then migrate.
- Remove legacy endpoints from `api.ts` only after the new tests pass against the new routes with unchanged behavior.

---

### Phase 7 — Validation Standardization (DTOs)

Files to add:
- `server/src/validation/<domain>.ts`: request DTO schemas and coercion for each domain. Keep them close to controllers.

Approach:
- Keep JSON-Schema/Ajv for dynamic inventory attributes.
- For request DTOs (query/body), use TypeScript-first schemas (code-only). If we later adopt `zod` or `valibot`, we’ll install with `pnpm add` and generate OpenAPI, but initial refactor will use lightweight manual validation to avoid churn.

Algorithms:
1) Parse → Coerce → Validate → Transform to service input type.
2) On validation failure, throw `ValidationError` with `{ field, reason }` details.

---

### Phase 8 — Error Handling and Response Shapes

Standardize HTTP error payloads:
- `{ error: { code: string, message: string, details?: any, requestId?: string } }`.
- Map common DB errors (unique violations, FK) to `ConflictError` or `ValidationError`.

Files to edit:
- Replace ad-hoc `return c.json({ error: '...' }, 400/409/500)` with throwing typed errors; middleware formats the response.

Tests:
- Unit: error mappers from domain/DB errors to `AppError` subclasses.
- Integration: assert standardized error envelopes and status codes for common failure paths across domains.

---

### Phase 9 — Pagination, Filtering, and Sorting Conventions

Conventions:
- Query params: `limit`, `offset` (or `cursor` future), `sort` (`field:asc|desc`), `q` for free-text search.
- Default `limit=25`, max `100`.

Files to add/edit:
- Use `http/pagination.ts` and `http/query.ts` helpers in all list endpoints.
- Update list endpoints in migrated routes; keep legacy behavior in legacy router until domain is migrated.

Tests:
- Integration: list endpoints respect defaults, max limits, sorting, and `q` search semantics. Assert envelopes/meta when adopted.

---

### Phase 10 — Transactions and Repository Boundaries

Files to edit:
- Add `withTransaction` in `lib/db.ts` and refactor multi-write services to use it.
- Ensure repositories accept either the root `db` or a transaction `tx` and never create their own connections.

Algorithm:
1) Controller resolves `db` from `getDatabase(getDatabaseUrl() || defaultLocal)` once per request (or reuse a request-scoped connection if we add one later).
2) Service calls `withTransaction` when needed; passes `tx` to repositories.
3) Repositories are pure data mappers: no business rules.

Tests:
- Unit: services that orchestrate multiple repositories use `withTransaction` correctly (commit/rollback behavior on error).
- Integration: multi-step operations remain atomic and yield identical externally observable results as before.

---

### Phase 11 — Observability and Logging

Files to add/edit:
- Structured logs at controller boundaries with `{ requestId, userId?, path, method, durationMs }`.
- Optionally add a request timing middleware and include DB timing in critical services.

Optional future:
- OpenTelemetry tracing (pnpm add `@opentelemetry/api` and SDK) is out-of-scope for this refactor but noted.

Tests:
- Integration: requestId present on error payloads, basic timing metadata correctness where applicable.

---

### Phase 12 — Documentation and OpenAPI (Optional Later)

Optional future improvement after stabilization:
- Adopt `@hono/zod-openapi` or `hono-openapi` generator; annotate controllers to produce OpenAPI.
- Publish `/api/openapi.json` and a Swagger UI in dev.

---

### Detailed Migration Steps (Small, Discrete PRs)

0) Phase T0 test platform: add Vitest config, DB harness, test app, fixtures, CI, and coverage. Capture golden-master tests for critical endpoints.
1) Phase 0 scaffolding: add `app.ts`, errors, http helpers, requestContext, errorHandler; wire `server.ts` to `app.ts`. No behavior changes. Ensure `buildApp()` test hooks exist.
2) Add `routes/index.ts` and `routes/legacy.ts`; mount legacy under `/api/v1`. Keep golden-master tests green.
3) Auth boundary: move `/protected/me` to `routes/auth.ts` + controller; remove legacy handler when tests pass.
4) Addresses domain: add controller/service/repo/route; cut over paths under `/api/v1/addresses`; remove legacy handlers when parity tests pass.
5) Inventory — Items: add controllers/repos/routes; align services to accept `dbOrTx`; cut over; remove legacy when tests pass.
6) Inventory — Transactions & Reservations: same as above; ensure transactional integrity; remove legacy when tests pass.
7) Events and Event Areas: extract controllers/repos/routes; reuse recurrence services; remove legacy when tests pass.
8) Departments: extract and cut over; remove legacy when tests pass.
9) Areas: extract and cut over; remove legacy when tests pass.
10) Employees & Positions: extract and cut over; remove legacy when tests pass.
11) Assignments, Schedules, Shifts: extract and cut over; remove legacy when tests pass.
12) Contacts: extract and cut over; remove legacy when tests pass.
13) Remove `api.ts` leftover code; keep as thin export or retire in favor of `app.ts`.
14) Validation pass: ensure all controllers use standardized DTOs and error mapping with tests covering invalid/edge scenarios.
15) Observability pass: add requestId to errors and logs; standardize response envelopes on new routes; expand tests.

Per-step validation (automated + manual):
- Tests-first: add/extend tests before code changes. PRs must keep the full suite green.
- Route parity: new route returns same payloads and status codes as legacy for identical inputs (assert in tests).
- Error parity: known invalid cases still return 400/401/403/404/409 as previously, with stable messages where feasible (assert standardized envelope when adopted).
- No leaked 500s on known validation failures; domain errors are mapped.
- Coverage thresholds met or justified per PR.

---

### File and Function Inventory (Initial Targets)

Must-read/modify early:
- `server/src/server.ts`
- `server/src/api.ts`
- `server/src/lib/db.ts` (add `withTransaction`)
- `server/src/middleware/auth.ts`
- `server/src/lib/validators.ts` (ensure lat/long, any missing helpers referenced by legacy code)
- `server/src/routes/eventSeries.ts` (adjust to controller/service once the events domain is migrated)

Test platform (new):
- `server/vitest.config.ts`
- `server/src/test/setup.ts`
- `server/src/test/testDb.ts`
- `server/src/test/testApp.ts`
- `server/src/test/fixtures/*`

New files (examples, created gradually):
- `server/src/app.ts`
- `server/src/routes/index.ts`
- `server/src/routes/legacy.ts`
- `server/src/routes/auth.ts`
- `server/src/routes/addresses.ts`
- `server/src/controllers/addressesController.ts`
- `server/src/services/addressesService.ts`
- `server/src/repositories/addressesRepo.ts`
- `server/src/routes/inventory/items.ts`
- `server/src/routes/inventory/transactions.ts`
- `server/src/routes/inventory/reservations.ts`
- `server/src/controllers/inventory/*`
- `server/src/repositories/inventory/*`
- `server/src/controllers/eventsController.ts`
- `server/src/repositories/eventsRepo.ts`
- `server/src/routes/events.ts`
- `server/src/middleware/errorHandler.ts`
- `server/src/middleware/requestContext.ts`
- `server/src/http/pagination.ts`
- `server/src/http/query.ts`
- `server/src/http/responses.ts`
- `server/src/errors/index.ts`
- `server/src/validation/*`

Notes on dependencies:
- Add dev-time testing deps in `server`: `vitest`, `@vitest/coverage-v8`. Ensure `@types/node` is present. Use `pnpm add -w -D` at the workspace root or within `server` per workspace setup.
- No other new packages required for the core refactor. If we choose to add schema libs or OpenAPI later, use `pnpm add` per repo rules (e.g., `pnpm add zod @hono/zod-openapi -w` if we centralize, or in `server` workspace only).

Out of scope for this refactor:
- Changing DB schema (except adding transactional helpers). Any schema changes should be separate features.
- Switching auth providers or permission model (can be layered later if required).

---

### Appendix — Controller/Service/Repository Flow Example (Algorithm)

Example: POST `/api/v1/addresses`
1) Controller parses body, calls validators/normalizers from `lib/validators.ts` and `validation/addresses.ts`.
2) On invalid input, throw `ValidationError({ field, reason })`.
3) Service checks primary-per-role rule and calls repository to insert. On unique violation, translate to `ConflictError('PrimaryExists')`.
4) Repository performs Drizzle insert and returns the new record.
5) Controller returns `{ data: record }` with 201.

Example: POST inventory transaction
1) Controller validates DTO; service calls `withTransaction` and applies domain rules across rows.
2) On constraint violation, map to `ValidationError`/`ConflictError`.
3) Return `{ data }` with resulting balances or affected rows count.


