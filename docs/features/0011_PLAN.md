Make Schedule button + auto-generate shifts for events

Context
- Add a "make schedule" button at the top of the list area in the Schedule view. Clicking it should "roll down a creation dialog like the rest in the application" where a user can "define the length of the schedule as well as name the schedule." On submit, "The schedule will then make a schedule record and make shifts for all the events in the date range and attach them to the schedule."

Scope
- UI: `ui/src/pages/Scheduling.tsx`
- Client API: `ui/src/lib/serverComm.ts`
- Server API: `server/src/api.ts`
- Validators/utilities already exist in `server/src/lib/validators.ts`

UI changes (Scheduling view)
- Location: At the top of the left list panel (same area as search/department and the existing New shift toggle), add a secondary button: "Make schedule".
- Behavior: Clicking toggles an inline creation panel (roll-down) consistent with existing inline creators in this app (match styles used for the New shift form).
- Fields in the panel:
  - Name: required
  - Start date: required (YYYY-MM-DD)
  - End date: required (YYYY-MM-DD; must be ≥ start)
  - Department(s) to generate shifts in: required for shift generation. Default to the currently selected Department if one is selected; allow multi-select to support multiple departments. If no department is selected and the user doesn’t choose one, block submission with a message.
  - Optional quick lengths: preset buttons (e.g., 1 week, 2 weeks, 4 weeks) that set end date relative to start. Presets are conveniences; the underlying payload remains explicit dates.
- Submission flow:
  1) Call client `createSchedule({ name, startDate, endDate })`.
  2) On success, immediately call client `generateShiftsForSchedule(scheduleId, { departmentIds })` to create shifts for all events in the date range and attach them to the schedule.
  3) Refresh schedules list and refresh shifts list (respecting current filters; if a department is selected, reload that department’s shifts for the schedule date range).
  4) Close panel and display a lightweight success toast or inline message.
- Error handling: show validation errors inline; show API errors at the top of the panel; disable the submit button while saving.

Client API additions (`ui/src/lib/serverComm.ts`)
- Add function: `generateShiftsForSchedule(scheduleId: string, payload: { departmentIds: string[] })` → POST `/api/v1/schedules/:scheduleId/generate-shifts`.
- Add to exported `api` object: `api.generateShiftsForSchedule`.
- No schema changes required on the client; reuse existing `ScheduleRecord` and `ShiftRecord` types.

Server API additions (`server/src/api.ts`)
- New protected endpoint: `POST /api/v1/schedules/:scheduleId/generate-shifts` with JSON body `{ departmentIds: string[] }`.
  - Validates: `scheduleId` exists; `departmentIds` is a non-empty array of valid department IDs.
  - Computes inclusive date range `[startDate, endDate]` from the schedule.
  - Queries events within that date window (inclusive) using `events.date` between `startDate` and `endDate`.
  - For each event and for each provided departmentId, create a shift:
    - `departmentId`: current department
    - `scheduleId`: the schedule
    - `eventId`: the event
    - `date`: `event.date`
    - `startTime`: `event.startTime`
    - `endTime`: `event.endTime`
    - `title`: `event.title`
  - Idempotency/duplication: before inserting, check if a shift already exists for `(scheduleId, eventId, departmentId)`. If yes, skip insert; if not, insert. Return counts: `{ created: number, skipped: number }` and an array of created shift IDs.
  - Wrap in a transaction to ensure consistency.
  - Returns `201` on success with `{ created, skipped, shifts: Shift[] }`.

Files/functions to change
- `ui/src/pages/Scheduling.tsx`
  - Add `Make schedule` button next to the `New` toggle.
  - Add new roll-down creation panel UI and local state: `creatingSchedule`, `name`, `startDate`, `endDate`, `selectedDepartmentIds: string[]`.
  - Wire submit handler to call `api.createSchedule`, then `api.generateShiftsForSchedule`, then refresh `api.listSchedules` and current shifts (`api.listShifts` or `api.listAllShifts` based on filters).
  - Ensure department filter state (`departmentId`) is used as default for `selectedDepartmentIds` when present.

- `ui/src/lib/serverComm.ts`
  - Add `export async function generateShiftsForSchedule(scheduleId: string, payload: { departmentIds: string[] })`.
  - Attach to `api` object as `api.generateShiftsForSchedule`.

- `server/src/api.ts`
  - Under Schedules routes, add `POST /schedules/:scheduleId/generate-shifts` implementing the algorithm above.
  - Use existing date/time validators: `isValidDateStr` for safeguards on schedule boundaries.
  - Query helpers: reuse `formatDate`/`formatTime` semantics if needed, but primarily filter by `events.date` between schedule start/end.
  - Use Drizzle to: fetch schedule, fetch events in range, upsert-or-skip shifts, return result payload.

Algorithms (server-side shift generation)
1) Parse `scheduleId` and body `departmentIds`.
2) Load schedule by ID; 404 if not found.
3) Validate `schedule.startDate`, `schedule.endDate` with `isValidDateStr` and ensure `startDate ≤ endDate`.
4) Fetch events where `events.date >= startDate` and `events.date <= endDate` (inclusive), ordered by date and startTime.
5) For each `(event, departmentId)` pair:
   - Check if a shift exists with same `scheduleId`, `eventId`, and `departmentId`.
   - If not exists: insert `{ departmentId, scheduleId, eventId, date: event.date, startTime: event.startTime, endTime: event.endTime, title: event.title }`.
   - Count `created` and collect created IDs; otherwise increment `skipped`.
6) Return `{ created, skipped, shifts }`.

Edge cases and decisions
- Empty event set in range: return `{ created: 0, skipped: 0, shifts: [] }`.
- Duplicates: handled by existence check; the operation is idempotent for the same inputs.
- Time validation: relies on `events.startTime < events.endTime`; existing data is assumed valid.
- Performance: perform existence checks batched by IDs per department when feasible; otherwise individual checks are acceptable for initial implementation.
- Publishing: schedules are created unpublished; generating shifts does not publish the schedule.

Open questions for confirmation
1) Department scope: Should shift generation target only the currently selected Department by default, or should we allow generating for multiple departments at once? The plan assumes multi-select with default = current selection when present.
   A: - Right now just single department
2) Length input: Is "length of the schedule" intended to be direct dates (Start/End) or a duration (e.g., N weeks) starting from a chosen start date? The plan proposes Start/End with optional quick duration presets.
   A: Start/End dates with presets for week/month
3) Shift title: Should the generated shift title always copy `event.title`, or remain empty/null? The plan defaults to copying `event.title`.
   A: Copy Event Title
4) Re-running generation: If the user re-runs generation for the same schedule and department(s), should existing generated shifts be overwritten or left as-is? The plan proposes idempotent skip behavior.
   A: Prompt user about existing shifts, on confirm delete old shifts, create new shifts unless schedule has been published, then fail. 
5) Event filtering: Include all events in the date range regardless of `status`, or only specific statuses (e.g., planned/confirmed)? The plan assumes all events; we can add a filter if needed.
   A: All events for the moment.

Phasing
- Phase 1: Server API
  - Implement `POST /api/v1/schedules/:scheduleId/generate-shifts` with transaction + idempotent inserts.
- Phase 2: Client API
  - Add `generateShiftsForSchedule` helper and export via `api` object.
- Phase 3: UI
  - Add Make schedule button + roll-down; wire form and submission flow; refresh data on success; polish UX.

Notes for environment/config
- No new environment variables are required.
- No database schema changes are required.


