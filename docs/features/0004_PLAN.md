## Feature Plan: Reusable List–Detail Framework (Generalize Events Page)

### Context
“Generalize the layout and functionality of the events page. The list selector/detail view will be a common way of handling information in this system. Let's make it so that we're reusing code efficiently.”

This plan extracts the list selector + detail view pattern from `ui/src/pages/Events.tsx` into shared, strongly-typed primitives to be reused across entities (e.g., events, users, departments, shifts). It preserves existing styling and UX (search, show-past toggle, sliding active indicator, optimistic edits, route-driven selection) while centralizing logic.

---

### Scope and touch points
- UI (React + Tailwind + ShadCN)
  - New shared feature module: `ui/src/features/listDetail/`
    - `types.ts`: Core generics (`IdType`, `ListItem<TId>`, `ResourceAdapter<TItem,TFilters,TQuery>`, `ListState<T>`, `FilterState`, `QueryState`)
    - `hooks/useListDetail.ts`: Data orchestration: load list, manage selection, route sync with `:id`, optimistic integration points
    - `hooks/useSlidingActiveIndicator.ts`: Sliding indicator measurement (shared with sidebar approach); takes a container ref and active selector
    - `hooks/useDebouncedPatch.ts`: Debounced, single-flight field update with AbortController and optimistic update contract
    - `components/ListDetailLayout.tsx`: Two-pane layout wrapper (left list column, right detail column), responsive and height-bound
    - `components/List.tsx`: Virtualizable-capable basic list rendering with active row class hook and empty/loading states
    - `components/FilterBar.tsx`: Composable search input + toggle controls (render-prop/slots), emits `QueryState` and `FilterState`
    - `components/CreateInline.tsx`: Collapsible inline creation surface (renders via render-prop so fields remain resource-specific)
    - `index.ts`: Barrel exports
  - Refactor `ui/src/pages/Events.tsx` to use the above primitives
  - Confirm `ui/src/App.tsx` keeps both routes: `/events` and `/events/:eventId` (already present)
  - Ensure classes already present in `ui/src/index.css` are reused: `.listActiveIndicator`, `.listRow`, `.listRowActive`, and drop page-specific `.eventItem--active` in favor of generic class wiring

- API client
  - Introduce an Events-specific `ResourceAdapter` in `ui/src/pages/Events.tsx` (or a colocated module) that wraps `serverComm` calls. No shape changes to `serverComm`.

- Server/API (Hono)
  - No required changes for this plan. Future entities should expose consistent list endpoints with `q`, optional filters, and stable id types to leverage the shared client.

---

### Detailed design

#### 1) Types and adapters (`ui/src/features/listDetail/types.ts`)
- Define:
  - `IdType` (string | number)
  - `ListItem<TId extends IdType>`: `{ id: TId } & Record<string, unknown>`
  - `QueryState`: `{ q?: string } & Record<string, unknown>`
  - `FilterState`: generic dictionary of filter keys
  - `ResourceAdapter<TItem, TFilters, TQuery>` with methods: `list(query, filters)`, `get(id)`, `create(partial)`, `update(id, patch)`
  - Optional `searchableFields` metadata for client-side highlighting or server query composition

Rationale: A stable adapter contract lets each resource (events, users, etc.) plug into the same list–detail experience without changing shared code.

#### 2) Data/controller hook (`ui/src/features/listDetail/hooks/useListDetail.ts`)
- Responsibilities:
  - Manage list loading state and items
  - Maintain `selectedId` derived from `react-router` `:id` param
  - Initialize selection on list load: if route id exists and found, select it; else select first; if not found, navigate to base route
  - Expose `select(id)` which updates URL (`push` to `/<resource>/:id`) and local state
  - Provide helpers for `create()` that prepends the new item and selects it
  - Handle reloading on `QueryState` or `FilterState` changes
  - Provide optional `preserveSelection` behavior across refetches

Inputs: `resourceKey` (e.g., "events"), `adapter`, and routing helpers. Outputs: `{ items, loading, selectedId, selected, select, reload, create }`.

#### 3) Sliding active indicator hook (`ui/src/features/listDetail/hooks/useSlidingActiveIndicator.ts`)
- Encapsulate measurement shared by `AppSidebar` and Events list:
  - Accepts `containerRef`, `activeSelector`, and optional callbacks
  - Computes `indicatorTop`, `indicatorHeight`, `hasActive`
  - Subscribes to scroll/resize and schedules with `requestAnimationFrame`
  - Returns values for style bindings and an imperative `measure()`

This replaces page-local implementations and standardizes the UX.

#### 4) Debounced field patch hook (`ui/src/features/listDetail/hooks/useDebouncedPatch.ts`)
- Provide API: `onChange(nextValue)`, `onBlurFlush()`, `cancel()`
- Internals:
  - Keep `pendingValue` and a timer (e.g., 400ms)
  - Abort in-flight PATCH with `AbortController` when a new value supersedes the old one
  - Call `adapter.update(id, patch)` with latest value only
  - Expose a guard so stale responses do not overwrite newer optimistic state

This generalizes the inline title edit behavior present in Events.

#### 5) Presentation components
- `ListDetailLayout.tsx`:
  - Grid or flex two-pane scaffold
  - Left column fixed width (e.g., 320–360px) with border; right column scrollable
  - Height matches `calc(100vh - navbarHeight)` consistent with Events

- `List.tsx`:
  - Renders `<ul>` of items using a render-prop: `(item, isActive) => ReactNode`
  - Applies `.listRow` and active class `.listRowActive` when `isActive`
  - Hosts `.listActiveIndicator` layer positioned via the sliding indicator hook
  - Handles empty and loading states

- `FilterBar.tsx`:
  - Provides search input and named slots for additional filters (e.g., a "Show past" checkbox for Events)
  - Emits controlled values for `QueryState` and `FilterState`

- `CreateInline.tsx`:
  - Wrapper that toggles visibility and renders a form via render-prop, deferring concrete fields to caller
  - Emits `onSubmit(partial)` and manages busy/error display

All components are headless enough to not constrain resource-specific fields but provide layout, state plumbing, and animations.

---

### Refactor: Events page to shared primitives
Target: `ui/src/pages/Events.tsx`

- Introduce an `eventsAdapter` that implements the `ResourceAdapter` methods by delegating to `serverComm` (`listEvents`, `getEvent`, `createEvent`, `updateEvent`).
- Replace local list/selection/fetching state with `useListDetail` outputs.
- Replace local sliding-indicator code with `useSlidingActiveIndicator` using a generic `.listRowActive` class or an explicit active selector.
- Replace inline title PATCH logic with `useDebouncedPatch` for the `title` field.
- Keep the existing detail form structure; just plug in the debounced updater for editable fields. Non-editable fields remain read-only as today.
- Use `FilterBar` to render the search input and the “Show past” toggle, mapping to `QueryState`/`FilterState` used by the adapter.
- Use `CreateInline` for the “New Event” form shell; the Events page continues to define event-specific inputs within it.
- Preserve route sync: clicking a row updates the URL to `/events/:eventId`; loading navigates back to `/events` if the param is not present in the list.

Styling: ensure `.listActiveIndicator`, `.listRow`, `.listRowActive` from `ui/src/index.css` are applied by the shared `List` component so events need not define `.eventItem` classes.

---

### Algorithms (step-by-step)

1) Selection and routing sync
  - On mount or on query/filter chaange: fetch list → if `:id` param is present and exists in list, select it; else select first item (if any)
  - On list item click: set `selectedId` and push `/<resource>/:id` route
  - On list refresh: keep current selection if still present; if not, clear selection and navigate to the base route

2) Sliding active indicator
  - Acquire `containerRect` and active row `rect`; compute `top = rect.top - containerRect.top + container.scrollTop` and `height = rect.height`
  - Update values on scroll, resize, and when items or selection changes; schedule with RAF to avoid layout thrash
  - Toggle opacity when there is no active row

3) Debounced PATCH
  - On input change: optimistically set local state; store value in `pendingValue`; schedule a timer (~400ms)
  - When timer fires: abort any in-flight request; send latest value with `adapter.update(id, patch)`; ignore outdated responses
  - On blur/unmount: flush if `pendingValue` is set; cancel timer and abort controller on cleanup

---

### File list
- New: `ui/src/features/listDetail/types.ts`
- New: `ui/src/features/listDetail/hooks/useListDetail.ts`
- New: `ui/src/features/listDetail/hooks/useSlidingActiveIndicator.ts`
- New: `ui/src/features/listDetail/hooks/useDebouncedPatch.ts`
- New: `ui/src/features/listDetail/components/ListDetailLayout.tsx`
- New: `ui/src/features/listDetail/components/List.tsx`
- New: `ui/src/features/listDetail/components/FilterBar.tsx`
- New: `ui/src/features/listDetail/components/CreateInline.tsx`
- New: `ui/src/features/listDetail/index.ts`
- Edited: `ui/src/pages/Events.tsx` (migrate to shared primitives)
- Reviewed (no change required): `ui/src/App.tsx`
- Reviewed (use existing classes): `ui/src/index.css`

---

### Notes and constraints
- Do not add new dependencies; rely on React, Tailwind, and ShadCN already in the project.
- Keep `serverComm` response shapes unchanged; `ResourceAdapter` adapts to current endpoint contracts.
- Maintain accessibility: keyboard navigation within the list (Up/Down/Home/End), ARIA roles (`listbox`/`option`), and focus management when selection changes.
- Large lists: design `List.tsx` API to optionally accept a virtualization strategy later (e.g., react-virtualized) without breaking callers, but defer implementation for now.

---

### Acceptance criteria
- Events page behavior and visuals remain functionally equivalent (search, show past toggle, create inline, selection, edit title debounced, route deep-linking).
- Shared primitives are in place and used by Events with minimal page-local logic.
- New resources can implement a `ResourceAdapter` and adopt the shared list–detail components without duplicating measurement, routing, or debounce logic.

---

### Optional follow-ups
- Add keyboard navigation and focus ring styles in `List.tsx` defaults.
- Extract sidebar’s active-indicator usage to the same `useSlidingActiveIndicator` for consistency.
- Provide a simple story/demo page for the list–detail kit to aid future development.


