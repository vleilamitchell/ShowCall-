### Recurring Events: series, templating, and auto-generation

Brief: Introduce the concept of a recurring event “series” with optional start/stop dates. A series templates event data (at minimum: start and stop time, and areas) and can automatically create concrete events in the series up to a specified date. Add a new Events sub-view called “Recurring” with a ListDetail editor for creating/editing series. The generation function must be highly editable and maintainable to support substantial future templating growth.

Assumptions and scope for v1 (explicit for clarity):
- Initial recurrence type: WEEKLY with an interval (e.g., every 1 week) and selected weekdays. Future-proof the data model for other frequencies.
- Series startDate and endDate are optional; generation is bounded by the requested untilDate and endDate if present.
- Template-able fields in v1: default status, startTime, endTime, and areas. Include optional string templates for title/promoter/artists for near-term growth.
- New events will link back to their series via `seriesId` on `events` to support idempotency and maintenance.

### Data layer (Phase 1 – migrations, schema, types)

Create new tables and extend `events`:
- server/drizzle/0023_event_series.sql
  - Table: `event_series`
    - `id text primary key`
    - `name text not null`
    - `description text null`
    - `start_date text null`  // YYYY-MM-DD
    - `end_date text null`    // YYYY-MM-DD
    - `default_status text not null default 'planned'`
    - `default_start_time text not null default '00:00'`
    - `default_end_time text not null default '23:59'`
    - `title_template text null`
    - `promoter_template text null`
    - `artists_template text null`
    - `template_json jsonb null`  // extensible bag for future templating
    - `updated_at timestamptz not null default now()`

- server/drizzle/0024_event_series_rules.sql
  - Table: `event_series_rules`
    - `id text primary key`
    - `series_id text not null references event_series(id) on delete cascade`
    - `frequency text not null`  // e.g., 'WEEKLY'
    - `interval int not null default 1`
    - `by_weekday_mask int not null default 0`  // bitmask for Sun..Sat (0..6)
    - `updated_at timestamptz not null default now()`
  - Index on (`series_id`)

- server/drizzle/0025_event_series_areas.sql
  - Table: `event_series_areas`
    - `series_id text not null references event_series(id) on delete cascade`
    - `area_id text not null references areas(id)`
    - Primary key (`series_id`, `area_id`)

- server/drizzle/0026_events_add_series_id.sql
  - Alter table `events` add column `series_id text null references event_series(id)`
  - Index on (`series_id`, `date`)

Add schema files and exports:
- server/src/schema/recurringSeries.ts
  - `eventSeries` mapping to `event_series`
  - `eventSeriesRules` mapping to `event_series_rules`
  - `eventSeriesAreas` mapping to `event_series_areas`
- server/src/schema/index.ts
  - Export `eventSeries`, `eventSeriesRules`, `eventSeriesAreas`
- server/src/schema/events.ts
  - Add nullable `seriesId` column mapping to `series_id`

Notes:
- Keep date/time as existing string formats for consistency (`YYYY-MM-DD`, `HH:mm`).
- Prefer simple WEEKLY+mask model now; schema is ready to add more columns for MONTHLY/DAILY in future migrations.

### Server API (Phase 2A – routes and service surface)

Add new REST resources (all protected via `authMiddleware`) under `/api/v1`:

- Event Series CRUD
  - `GET /event-series?q&from&to` – list series; optional search by name/description; option to filter intersecting date windows `from/to` against series start/end.
  - `POST /event-series` – create series. Body includes: `name`, `description?`, `startDate?`, `endDate?`, default templating fields (`defaultStatus`, `defaultStartTime`, `defaultEndTime`, `titleTemplate?`, `promoterTemplate?`, `artistsTemplate?`, `templateJson?`). Also accept a `rule` object for initial recurrence (frequency=WEEKLY, interval, byWeekdayMask).
  - `GET /event-series/:seriesId`
  - `PATCH /event-series/:seriesId` – partial update; validates date formats and time formats.
  - `DELETE /event-series/:seriesId` – delete series + rules + series areas; does NOT delete events by default.

- Series Areas (modeled like Event Areas)
  - `GET /event-series/:seriesId/areas` – list areas for a series (join to `areas` for details)
  - `PUT /event-series/:seriesId/areas` – replace with `{ areaIds: string[] }` idempotently
  - `POST /event-series/:seriesId/areas` – add single `{ areaId }` idempotently
  - `DELETE /event-series/:seriesId/areas/:areaId`

- Generation & Preview
  - `POST /event-series/:seriesId/preview` – body `{ fromDate?, untilDate }`; returns computed occurrence dates and the event payloads that would be created (without writes), including area ids that would be applied.
  - `POST /event-series/:seriesId/generate` – body `{ fromDate?, untilDate, overwriteExisting?: boolean, setAreasMode?: 'replace' | 'skip' }`. Creates or updates concrete events for each computed date. Returns counts: `{ created, updated, skipped }` and ids.

API files to update:
- `server/src/api.ts` – add new routers: `seriesRoutes` under `/event-series`, and nested `seriesAreasRoutes` under `/event-series/:seriesId/areas`. Reuse existing helpers (`getDatabase`, `validators`, `authMiddleware`).
- `server/src/lib/validators.ts` – add: `isValidWeekdayMask(n)`, `isValidFrequency(s)` and reuse `isValidDateStr`/`isValidTimeStr`.

### Server services (Phase 2B – generation engine and template application)

Create maintainable, modular services to keep logic isolated and testable:
- `server/src/services/events/recurrence.ts`
  - `computeOccurrences(series, rule, { fromDate?, untilDate }): string[]`
    - Determine effective window: `start = max(series.startDate || -inf, fromDate || today)`, `end = min(series.endDate || +inf, untilDate)`.
    - For WEEKLY: iterate calendar days from `start` to `end` inclusive; include date if its weekday bit is set and the week offset from the series anchor satisfies `weekIndex % interval === 0`.
    - Returns array of date strings `YYYY-MM-DD`.
  - `buildEventTemplate(series): { template, mergeStrategy }`
    - Produce a normalized template object from series defaults and templates.
    - `mergeStrategy` is a per-field strategy map: `'overwrite' | 'fillEmpty' | 'append'` for maintainability. v1: startTime/endTime = overwrite; status = overwrite; title/promoter/artists = fillEmpty; URLs = fillEmpty.
  - `applyTemplateToEvent(existingOrNew, template, mergeStrategy): EventRecord`
    - Apply strategies deterministically; no inline branching elsewhere.
  - `upsertEventsForSeries(seriesId, { fromDate?, untilDate, overwriteExisting, setAreasMode }): { created, updated, skipped, eventIds }`
    - Load series, rule, and series areas.
    - Compute occurrences.
    - For each date:
      - If no event exists for (`seriesId`, `date`): create event with template fields; after insert, set areas via `eventAreas` routes/repo.
      - If exists and `overwriteExisting`: patch event via `applyTemplateToEvent`; optionally replace areas when `setAreasMode==='replace'`.
      - Else skip.
    - Use batched inserts/updates where possible; wrap in a transaction.

Notes:
- Keep services framework-agnostic; call from API layer. Favor small, pure helpers.
- Ensure idempotency: unique lookup by (`seriesId`,`date`). Consider a DB unique index if desired later.

### UI (Phase 3 – new Recurring view with ListDetail)

Add a new page and components for series management:
- `ui/src/pages/EventsRecurring.tsx`
  - Implements `ListDetailLayout` similar to `Events.tsx`.
  - Left list: search by `name`, optional filters: “In window” (`from/to`), and toggle for “Active only” (active = current date within start/end or no end).
  - Row shows series name and a compact weekday mask chip string (e.g., Mo/Tu/Fr).
  - Actions per row: Delete series.
  - Right detail editor panels:
    - Header: editable `name`.
    - Basics: `startDate?`, `endDate?`, `defaultStatus`, `defaultStartTime`, `defaultEndTime`.
    - Templates: `titleTemplate?`, `promoterTemplate?`, `artistsTemplate?` (plain inputs; render-only in v1).
    - Recurrence: `RecurringRuleEditor` (checklist for weekdays, numeric interval).
    - Areas: `SeriesAreasPanel` (mirrors `EventAreasPanel` but uses series endpoints; bulk replace via PUT).
    - Generation: “Generate events…” button -> modal: pick `untilDate`, `overwriteExisting`, `setAreasMode`. Provide a Preview tab that calls `/preview`.

Navigation and routes:
- `ui/src/App.tsx` – add route for `/events/recurring` → `EventsRecurring`.
- `ui/src/components/appSidebar.tsx` – add nav item under Events labeled “Recurring”.

ServerComm additions:
- `ui/src/lib/serverComm.ts`
  - Types: `EventSeries`, `EventSeriesRule`.
  - Functions: `listEventSeries`, `createEventSeries`, `getEventSeries`, `updateEventSeries`, `deleteEventSeries`, `getEventSeriesAreas`, `putEventSeriesAreas`, `addEventSeriesArea`, `removeEventSeriesArea`, `previewEventSeries`, `generateEventSeries`.
  - ResourceAdapter for ListDetail.

### Algorithms (step-by-step)

WEEKLY rule date generation (byWeekdayMask + interval):
1. Input: `series.startDate?`, `series.endDate?`, `rule.interval`, `rule.byWeekdayMask`, `fromDate?`, `untilDate`.
2. Compute `windowStart = max(fromDate || today, series.startDate || -inf)`; `windowEnd = min(untilDate, series.endDate || +inf)`.
3. Anchor week: the Monday (or Sunday) of `series.startDate || windowStart` to compute week indices deterministically.
4. Iterate days `d` from `windowStart` to `windowEnd` inclusive:
   - If `(weekdayMask & (1 << weekday(d))) === 0` → continue.
   - Let `weeksSinceAnchor = floor((d - anchorStartOfWeek)/7days)`.
   - If `weeksSinceAnchor % interval !== 0` → continue.
   - Yield `formatDate(d)`.

Template application and merging:
1. Build `template` from series defaults and optional templates.
2. For each occurrence date, look up existing event by (`seriesId`,`date`).
3. If none: create event with `seriesId`, `date`, `startTime`, `endTime`, `status`, and optional template fields (title/promoter/artists if present).
4. If exists and `overwriteExisting`:
   - For fields with strategy `overwrite` (start/end/status), set to template value.
   - For `fillEmpty` fields (title/promoter/artists), set only if event field is empty/null.
5. Areas:
   - If creating: apply series areas as the event’s areas (PUT replace).
   - If updating and `setAreasMode==='replace'`: replace event areas with series areas.
6. Track counts and return summary.

### Files to add/change

- Server
  - Add: `server/src/schema/recurringSeries.ts`
  - Change: `server/src/schema/events.ts` (add `seriesId`)
  - Change: `server/src/schema/index.ts` (export new tables)
  - Add: `server/src/services/events/recurrence.ts`
  - Change: `server/src/lib/validators.ts` (frequency/weekday validation)
  - Change: `server/src/api.ts` (mount `event-series` routes and nested areas)
  - Add migrations: `server/drizzle/0023_event_series.sql`, `0024_event_series_rules.sql`, `0025_event_series_areas.sql`, `0026_events_add_series_id.sql`

- UI
  - Add: `ui/src/pages/EventsRecurring.tsx`
  - Change: `ui/src/App.tsx` (route)
  - Change: `ui/src/components/appSidebar.tsx` (nav link)
  - Change: `ui/src/lib/serverComm.ts` (client methods and types)
  - Add: `ui/src/features/events/RecurringRuleEditor.tsx` (weekday checklist + interval)
  - Add: `ui/src/features/events/SeriesAreasPanel.tsx` (reuse patterns from `EventAreasPanel`)

### Notes for future growth

- Add support for additional frequencies and constraints: DAILY, MONTHLY (by month day, by nth weekday), EXCEPTIONS (skip dates), and SHIFTED instances.
- Promote `template_json` into a typed, versioned schema if/when needed.
- Consider a unique index on `events(series_id, date)` to enforce idempotency at DB level.
- Consider background worker or cron-like endpoint for periodic auto-generation.


